import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { useNavigate, useParams, useLocation } from 'react-router-dom';
import styled, { css, keyframes, useTheme } from 'styled-components';
import { Tab, Tabs, TabList, TabPanel } from 'react-tabs';
import 'react-tabs/style/react-tabs.css';
import { db } from '../firebase';
import { 
  collection, 
  addDoc, 
  getDocs, 
  deleteDoc, 
  doc, 
  query, 
  where,
  updateDoc,
  writeBatch,
  getDoc,
  runTransaction,
  setDoc,
  onSnapshot,
  increment,
  serverTimestamp
} from 'firebase/firestore';
import { useAuth } from '../contexts/AuthContext';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import TradingChartComponent from '../components/TradingChart';
import { tradingService } from '../services/tradingService';
import btcIcon from '../assets/images/coin/btc.png';
import LightweightChartComponent from '../components/LightweightChartComponent';
import soundEffect from '../assets/sound/sound-effect.wav';

// Import our price validation utilities
import { 
  validatePrice, 
  isExtremeMarketMovement, 
  getMedianPrice,
  calculateLiquidationPrice,
  PriceConsistencyTracker
} from '../utils/priceValidation';

// Simple notification function using console.log
const addNotification = ({ title, message, type, playSound = false }) => {
  console.log(`[${type || 'info'}] ${title}: ${message}`);
  // Play sound if requested
  if (playSound) {
    try {
      const audio = new Audio(soundEffect);
      audio.play().catch(error => {
        console.warn('Error playing notification sound:', error);
      });
    } catch (error) {
      console.warn('Error initializing notification sound:', error);
    }
  }
  // In a real app, we would use a proper notification library
};

const TradingContainer = styled.div`
  padding: 20px;
  background: var(--bg1);
  min-height: calc(100vh - 100px);
  margin-top: 0;
  
  @media (max-width: 768px) {
    padding: 10px;
    margin-top: 0;
  }
`;

const SearchContainer = styled.div`
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 10px;
`;

const TradingHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
  
  @media (max-width: 768px) {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }
`;

const TradingGrid = styled.div`
  display: grid;
  grid-template-columns: 65% 35%;
  gap: 1px;
  margin-top: 5px;
  margin-bottom: 30px;
  background: var(--bg);
  
  @media (max-width: 1200px) {
    grid-template-columns: 60% 40%;
  }
  
  @media (max-width: 992px) {
    grid-template-columns: 1fr;
  }
  
  @media (max-width: 768px) {
    margin-top: 3px;
    margin-bottom: 20px;
  }
`;

const ChartSection = styled.div`
  background: var(--bg);
  border-right: 1px solid var(--line);
  height: 350px;
  
  @media (max-width: 992px) {
    border-right: none;
    border-bottom: 1px solid var(--line);
  }
  
  @media (max-width: 768px) {
    height: 300px;
  }
`;

const RightSection = styled.div`
  width: 100%;
  background: var(--bg);
  display: grid;
  grid-template-rows: auto;
  height: 350px;
  
  @media (max-width: 992px) {
    width: 100%;
  }
  
  @media (max-width: 768px) {
    height: auto;
  }
`;

const TradingInterface = styled.div`
  display: grid;
  grid-template-columns: 50% 50%;
  width: 100%;
  
  @media (max-width: 992px) {
    grid-template-columns: 1fr 1fr;
    border-left: none;
  }
  
  @media (max-width: 576px) {
    grid-template-columns: 1fr;
  }
`;

const OrderBookSection = styled.div`
  // height: 350px;
  border-right: 1px solid var(--line);
  padding: 6px;
  display: flex;
  flex-direction: column;
  border: 1px solid #D4AF37;
  box-shadow: 0 0 8px rgba(212, 175, 55, 0.2);
  border-radius: 12px;
  margin: 3px;
  overflow: hidden;
  
  @media (max-width: 992px) {
    height: 330px;
  }
  
  @media (max-width: 768px) {
    height: 300px;
  }
`;

const OrderFormSection = styled.div`
  padding: 6px;
  height: 400px;
  display: flex;
  flex-direction: column;
  border: 1px solid #D4AF37;
  box-shadow: 0 0 8px rgba(212, 175, 55, 0.2);
  border-radius: 12px;
  margin: 3px;
  
  @media (max-width: 992px) {
    height: 330px;
  }
  
  @media (max-width: 768px) {
    height: 300px;
  }
`;

const ChartCard = styled.div`
  background: var(--bg);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 20px;
  
  @media (max-width: 768px) {
    padding: 12px;
    border-radius: 8px;
  }
`;

const OrderCard = styled.div`
  background: var(--bg);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 20px;
  height: 100%;
  overflow-y: auto;
  
  @media (max-width: 768px) {
    padding: 12px;
    border-radius: 8px;
  }
`;

const CoinInfo = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
  
  @media (max-width: 768px) {
    gap: 8px;
    margin-bottom: 15px;
  }
`;

const CoinIcon = styled.img`
  width: 40px;
  height: 40px;
  border-radius: 50%;
  object-fit: contain;
  background: ${props => props.$theme === 'dark' ? '#2A2A3C' : '#fff'};
  padding: 2px;
  
  @media (max-width: 768px) {
    width: 32px;
    height: 32px;
  }
`;

const CoinDetails = styled.div`
  display: flex;
  flex-direction: column;
`;

const CoinName = styled.h2`
  color: #fff;
  margin: 0;
  font-size: 24px;
  
  @media (max-width: 768px) {
    font-size: 20px;
  }
`;

const CoinSymbol = styled.span`
  color: #7A7A7A;
  font-size: 16px;
  
  @media (max-width: 768px) {
    font-size: 14px;
  }
`;

const PriceInfo = styled.div`
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
  
  @media (max-width: 768px) {
    gap: 12px;
    margin-bottom: 15px;
    flex-direction: column;
  }
`;

const Price = styled.div`
  color: #fff;
  font-size: 24px;
  font-weight: 500;
  
  @media (max-width: 768px) {
    font-size: 20px;
  }
`;

const Change = styled.span`
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 14px;
  background: ${props => props.$isPositive ? 'rgba(14, 203, 129, 0.2)' : 'rgba(246, 70, 93, 0.2)'};
  color: ${props => props.$isPositive ? '#0ECB81' : '#F6465D'};
  margin-left: 8px;
  
  @media (max-width: 768px) {
    font-size: 12px;
    padding: 1px 6px;
  }
`;

const OrderForm = styled.form`
  display: flex;
  flex-direction: column;
  padding: 6px 0;
  gap: 6px;
  height: 100%;
  
  @media (max-width: 768px) {
    padding: 4px 0;
    gap: 4px;
  }
`;

const TabGroup = styled.div`
  display: flex;
  margin-bottom: 6px;
  gap: 6px;
  
  @media (max-width: 768px) {
    margin-bottom: 4px;
    gap: 3px;
  }
`;

const OrderTab = styled.button`
  background: ${props => props.$active ? 'var(--primary)' : 'var(--bg2)'};
  color: ${props => props.$active ? 'var(--text-white)' : 'var(--text)'};
  border: none;
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  flex: 1;
  outline: none;
  
  &:hover {
    background: ${props => props.$active ? 'var(--primary)' : 'var(--bg3)'};
  }
  
  @media (max-width: 768px) {
    padding: 5px 10px;
    font-size: 12px;
  }
`;

const AmountInput = styled.input`
  background: var(--bg2);
  color: var(--text);
  border: 1px solid var(--line);
  padding: 6px 10px;
  font-size: 13px;
  border-radius: 8px;
  outline: none;
  transition: all 0.2s;
  width: 100%;
  margin: 2px 0;
  
  &:focus {
    border-color: #D4AF37;
    box-shadow: 0 0 4px rgba(212, 175, 55, 0.3);
  }
  
  @media (max-width: 768px) {
    padding: 5px 8px;
    font-size: 12px;
    margin: 1px 0;
  }
`;

const Button = styled.button`
  background: ${props => props.$variant === 'buy' ? 'var(--success)' : props.$variant === 'sell' ? 'var(--danger)' : 'var(--primary)'};
  color: white;
  border: none;
  padding: 8px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  margin-top: 5px;
  border: 1px solid ${props => {
    if (props.$variant === 'buy') return 'rgba(212, 175, 55, 0.5)';
    if (props.$variant === 'sell') return 'rgba(212, 175, 55, 0.5)';
    return '#D4AF37';
  }};
  box-shadow: 0 0 4px ${props => {
    if (props.$variant === 'buy') return 'rgba(52, 199, 89, 0.3)';
    if (props.$variant === 'sell') return 'rgba(255, 59, 48, 0.3)';
    return 'rgba(212, 175, 55, 0.3)';
  }};
  
  &:hover {
    filter: brightness(1.1);
  }
  
  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  @media (max-width: 768px) {
    padding: 6px;
    font-size: 13px;
  }
`;

// Update the TIMEFRAMES object
const TIMEFRAMES = {
  '1D': { label: '1D', value: '1' },
  '1W': { label: '1W', value: '7' }
};

// Update the styled component for the chart
const ChartEmbed = styled.iframe`
  width: 100%;
  height: 600px;
  border: none;
  border-radius: 8px;
  background: var(--bg2);
`;

const CurrentPrice = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 16px;
  padding: 8px 0;
  margin: 5px 0;
  position: relative;
  color: ${props => props.$isUp ? '#0ECB81' : '#F6465D'};
  background: ${props => props.$isUp ? 'rgba(14, 203, 129, 0.15)' : 'rgba(246, 70, 93, 0.15)'};
  border-top: 1px solid ${props => props.$isUp ? 'rgba(14, 203, 129, 0.3)' : 'rgba(246, 70, 93, 0.3)'};
  border-bottom: 1px solid ${props => props.$isUp ? 'rgba(14, 203, 129, 0.3)' : 'rgba(246, 70, 93, 0.3)'};
  letter-spacing: 0.5px;
`;

// Replace the InternalTradingChart function
function InternalTradingChart({ symbol, theme }) {
  return (
    <TradingChartComponent
      symbol={`BINANCE:${symbol}`}
      theme={theme}
      container_id="tradingview_chart"
      autosize={true}
      timeframe="15"
      allow_symbol_change={false}
    />
  );
}

// Define accurate coin IDs for CoinGecko
const hardcodedPrices = {
  'btc': 90812.45,
  'bitcoin': 90812.45,
  'eth': 3452.67,
  'ethereum': 3452.67,
  'sol': 142.56,
  'bnb': 567.89,
  'doge': 0.12
};

// Define accurate coin IDs for CoinGecko
const COINGECKO_IDS = {
  'btc': 'bitcoin',
  'bitcoin': 'bitcoin',
  'eth': 'ethereum', 
  'ethereum': 'ethereum',
  'sol': 'solana',
  'bnb': 'binancecoin',
  'doge': 'dogecoin',
  'xrp': 'ripple',
  'ada': 'cardano',
  'dot': 'polkadot',
  'matic': 'matic-network',
  'avax': 'avalanche-2',
  'link': 'chainlink',
  'uni': 'uniswap',
  'atom': 'cosmos'
};

const fetchHistoricalData = async (coinId, days = '1', interval = 'minute') => {
  try {
    const response = await fetch(
      `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=${days}&interval=${interval}`
    );
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    
    // Convert the data to candlestick format
    const candlesticks = [];
    const prices = data.prices;
    
    for (let i = 0; i < prices.length; i += 1) {
      const candle = {
        time: prices[i][0] / 1000, // Convert to seconds
        open: prices[i][1],
        high: prices[i][1],
        low: prices[i][1],
        close: prices[i][1]
      };
      
      if (i > 0) {
        candle.open = prices[i-1][1];
        candle.high = Math.max(candle.open, candle.close);
        candle.low = Math.min(candle.open, candle.close);
      }
      
      candlesticks.push(candle);
    }
    
    return candlesticks;
  } catch (error) {
    console.error('Error fetching historical data:', error);
    return null;
  }
};

// Add these new styled components
const OrderTypeSelector = styled.div`
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
`;

const leverageOptions = [10, 20, 25, 30, 40];  // Updated leverage options

const LeverageSlider = styled.input`
  -webkit-appearance: none;
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: var(--bg2);
  outline: none;
  margin: 10px 0;
  
  &::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: ${props => props.$value >= 30 ? '#F6465D' : 'var(--primary)'};
    cursor: pointer;
  }
  
  &::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: ${props => props.$value >= 30 ? '#F6465D' : 'var(--primary)'};
    cursor: pointer;
    border: none;
  }
`;

const LeverageDisplay = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 4px;
  color: var(--text);
  font-size: 12px;
`;

const QuickLeverageButtons = styled.div`
  display: flex;
  gap: 4px;
  margin-top: 4px;
`;

const QuickLeverageButton = styled.button`
  padding: 4px 8px;
  margin: 0 4px;
  border-radius: 4px;
  border: none;
  font-size: 12px;
  cursor: pointer;
  transition: background 0.2s;
  background: ${props => props.$active ? 'var(--primary)' : 'var(--bg1)'};
  color: ${props => props.$active ? '#fff' : 'var(--text)'};
  
  &:hover {
    background: var(--primary);
    color: #fff;
  }
`;

const OrderDetails = styled.div`
  margin-top: 5px;
  margin-bottom: 5px;
`;

const DetailRow = styled.div`
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
  color: var(--text);
  font-size: 12px;
`;

// Add these new styled components
const OrderBook = styled.div`
  height: 100%;
  display: flex;
  flex-direction: column;
  background: var(--bg2);
  border-radius: 12px;
  border: 1px solid #D4AF37; /* Golden border color */
  box-shadow: 0 0 8px rgba(212, 175, 55, 0.2); /* Subtle golden glow */
  overflow: hidden;
  
  @media (max-width: 768px) {
    max-height: 300px;
    overflow-y: auto;
  }
`;

const OrderBookHeader = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  padding: 8px;
  font-size: 12px;
  color: var(--text-secondary);
  border-bottom: 1px solid var(--line);
  text-align: right;
  
  span:first-child {
    text-align: left;
  }
  
  @media (max-width: 768px) {
    padding: 6px;
    font-size: 11px;
  }
`;

const OrderBookRow = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  padding: 4px 8px;
  font-size: 12px;
  cursor: pointer;
  position: relative;
  text-align: right;
  transition: background 0.1s;
  
  &:hover {
    background: rgba(255, 255, 255, 0.05);
  }
  
  &::before {
    content: '';
    position: absolute;
    top: 0;
    ${props => props.$side === 'buy' ? 'right' : 'left'}: 0;
    height: 100%;
    width: ${props => props.$depth || 0}%;
    background: ${props => props.$side === 'buy' 
      ? 'rgba(52, 199, 89, 0.1)' 
      : 'rgba(255, 59, 48, 0.1)'};
    z-index: 0;
    pointer-events: none;
  }
  
  span {
    position: relative;
    z-index: 1;
  }
  
  span:first-child {
    text-align: left;
  }
  
  &.flash {
    animation: flash 0.5s;
  }
  
  @keyframes flash {
    0% { background-color: rgba(255, 255, 255, 0.1); }
    100% { background-color: transparent; }
  }
  
  @media (max-width: 768px) {
    padding: 3px 6px;
    font-size: 11px;
  }
`;

// Update OrderCard to include buy/sell colors
const OrderButton = styled.button`
  background: ${props => props.$orderType === 'buy' ? '#0ECB81' : '#F6465D'};
  color: white;
  border: none;
  padding: 8px;
  border-radius: 6px;
  cursor: pointer;
  width: 100%;
  font-weight: 500;
  font-size: 13px;
  border: 1px solid ${props => props.$orderType === 'buy' ? 'rgba(14, 203, 129, 0.5)' : 'rgba(246, 70, 93, 0.5)'};
  box-shadow: 0 0 4px ${props => props.$orderType === 'buy' ? 'rgba(14, 203, 129, 0.3)' : 'rgba(246, 70, 93, 0.3)'};
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  &:hover:not(:disabled) {
    filter: brightness(1.1);
  }
  
  @media (max-width: 768px) {
    padding: 6px;
    font-size: 12px;
  }
`;

// Add a new container for the right side
const RightPanel = styled.div`
  display: grid;
  grid-template-rows: 1fr 1fr;
  gap: 20px;
  height: 600px; // Match chart height
`;

// Update the positions table styling
const PositionsTable = styled.table`
  width: 100%;
  border-collapse: collapse;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 0 12px rgba(212, 175, 55, 0.4);
  border: 1px solid #D4AF37;
  animation: fadeIn 1s ease-in-out;

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  @media (max-width: 768px) {
    /* Mobile-specific styles */
    font-size: 12px;
  }
`;

const TableHeader = styled.th`
  background: rgba(212, 175, 55, 0.2);
  color: #D4AF37;
  padding: 8px;
  font-size: 12px;
  text-align: left;
  
  @media (max-width: 768px) {
    /* Hide specific columns on mobile */
    &:nth-child(2), /* Amount */
    &:nth-child(3), /* Entry Price */
    &:nth-child(4), /* Mark Price */
    &:nth-child(5), /* Liquidation */
    &:nth-child(6) { /* Leverage */
      display: none;
    }
  }
`;

const TableCell = styled.td`
  padding: 6px 8px;
  font-size: 12px;
  color: var(--text);
  border-bottom: 1px solid rgba(212, 175, 55, 0.1);
  
  @media (max-width: 768px) {
    /* Hide specific columns on mobile */
    &:nth-child(2), /* Amount */
    &:nth-child(3), /* Entry Price */
    &:nth-child(4), /* Mark Price */
    &:nth-child(5), /* Liquidation */
    &:nth-child(6) { /* Leverage */
      display: none;
    }
    
    /* Style for the symbol that appears next to the type on mobile */
    .mobile-only-symbol {
      display: inline-block;
      font-size: 12px;
      opacity: 1;
      margin-left: 6px;
      color: #D4AF37; /* Gold color for better visibility */
      font-weight: bold;
    }
  }
  
  /* Hide the symbol on desktop */
  .mobile-only-symbol {
    display: none;
  }
`;

const PnLValue = styled.span`
  color: ${props => props.value >= 0 ? '#0ECB81' : '#F6465D'};
  font-weight: bold;
`;

// Add these styled components at the top with your other styled components
const TradeInfo = styled.div`
  margin-top: 5px;
  background: rgba(30, 41, 59, 0.4);
  border-radius: 6px;
  padding: 6px 8px;
  font-size: 12px;
`;

const InfoItem = styled.div`
  display: flex;
  justify-content: space-between;
  color: ${props => props.$highlight ? 'var(--primary)' : 'var(--text-secondary)'};
  margin-bottom: 3px;
  
  &:last-child {
    margin-bottom: 0;
  }
`;

// Add this helper function before the Trading component
const calculateRequiredMargin = (amount, price, leverage) => {
  if (!amount || !price || !leverage) return 0;
  return (parseFloat(amount) * price) / leverage;
};

// Update the leverage buttons handling
const LeverageButtons = styled.div`
  display: flex;
  gap: 8px;
  margin-top: 8px;
`;

const LeverageInput = styled.input`
  width: 100%;
  padding: 8px;
  margin-top: 8px;
  background: var(--bg2);
  border: 1px solid var(--line);
  color: var(--text);
  border-radius: 4px;
`;

// Add these styled components
const ChartContainer = styled.div`
  position: relative;
  background: var(--bg1);
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 20px;
  border: 1px solid #D4AF37; /* Golden border color */
  box-shadow: 0 0 8px rgba(212, 175, 55, 0.2); /* Subtle golden glow */
`;

const DexLink = styled.a`
  display: inline-block;
  padding: 8px 12px;
  background: rgba(30, 34, 45, 0.8);
  color: var(--text-secondary);
  font-size: 13px;
  text-decoration: none;
  border-radius: 4px;
  position: absolute;
  right: 24px;
  bottom: 24px;
  transition: all 0.2s;
  
  &:hover {
    background: var(--primary);
    color: white;
  }
  
  i {
    margin-left: 5px;
    font-size: 12px;
  }
`;

const TimeframeSelector = styled.div`
  display: flex;
  gap: 4px;
  padding: 8px;
  position: absolute;
  top: 8px;
  right: 8px;
  z-index: 2;
  background: rgba(30, 34, 45, 0.8);
  border-radius: 4px;
`;

const TimeButton = styled.button`
  padding: 4px 12px;
  background: ${props => props.$active ? 'var(--primary)' : 'transparent'};
  color: ${props => props.$active ? 'white' : '#7a7a7a'};
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s;

  &:hover {
    color: white;
    background: ${props => props.$active ? 'var(--primary)' : 'rgba(71, 77, 87, 0.7)'};
  }
`;

// Add this styled component
const DexScreenerChart = styled.iframe`
  width: 100%;
  height: 500px;
  border: none;
  border-radius: 8px;
  background: var(--bg2);
`;

// Add these new styled components after the existing styled components
const TradesList = styled.div`
  max-height: 80px;
  overflow-y: auto;
  padding: 4px 0;
  background: var(--bg);
  border-top: none;
  border-bottom: none;
  &::-webkit-scrollbar {
    width: 5px;
  }
  &::-webkit-scrollbar-thumb {
    background: rgba(128, 128, 128, 0.3);
    border-radius: 4px;
  }
`;

const TradeRow = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  padding: 4px 8px;
  font-size: 12px;
  animation: fadeIn 0.3s ease-in-out;
  
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateX(${props => props.$isBuy ? '-10px' : '10px'});
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  & > span {
    &:first-child {
      color: ${props => props.$isBuy ? '#0ECB81' : '#F6465D'};
    }
    &:nth-child(2),
    &:last-child {
      text-align: right;
    }
  }
`;

// Add these styled components after the existing styled components
const OrderBookContent = styled.div`
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  height: calc(100% - 32px);
`;

const AsksContainer = styled.div`
  flex: 1;
  overflow-y: auto;
  /* Use more subtle background with less opacity */
  background: var(--bg); 
  display: flex;
  flex-direction: column-reverse;
  min-height: 200px;
  &::-webkit-scrollbar {
    width: 5px;
  }
  &::-webkit-scrollbar-thumb {
    background: rgba(246, 70, 93, 0.1);
    border-radius: 4px;
  }
`;

const BidsContainer = styled.div`
  flex: 1;
  overflow-y: auto;
  /* Use same background as AsksContainer */
  background: var(--bg);
  min-height: 200px;
  &::-webkit-scrollbar {
    width: 5px;
  }
  &::-webkit-scrollbar-thumb {
    background: rgba(14, 203, 129, 0.1);
    border-radius: 4px;
  }
`;

// Fix the calculatePnL function
const calculatePnL = (position, currentMarketPrice) => {
  if (!position || !position.entryPrice || !currentMarketPrice) return 0;
  
  const { type, entryPrice, leverage, margin } = position;
  
  try {
    // Ensure all values are proper numbers
    const entryPriceNum = parseFloat(entryPrice);
    const currentMarketPriceNum = parseFloat(currentMarketPrice);
    const leverageNum = parseFloat(leverage);
    const marginNum = parseFloat(margin);
    
    // Validation
    if (isNaN(entryPriceNum) || isNaN(currentMarketPriceNum) || isNaN(leverageNum) || isNaN(marginNum)) {
      console.error('Invalid values for PnL calculation:', { entryPrice, currentMarketPrice, leverage, margin });
      return 0;
    }
    
    if (type === 'buy') {
      const priceDiff = currentMarketPriceNum - entryPriceNum;
      const percentageChange = (priceDiff / entryPriceNum) * 100;
      return +(marginNum * (percentageChange / 100) * leverageNum).toFixed(2);
    } else {
      const priceDiff = entryPriceNum - currentMarketPriceNum;
      const percentageChange = (priceDiff / entryPriceNum) * 100;
      return +(marginNum * (percentageChange / 100) * leverageNum).toFixed(2);
    }
  } catch (error) {
    console.error('Error calculating PnL:', error);
    return 0;
  }
};

// Generate random quantity based on price range
const generateRandomQty = (price) => {
  // For very low-priced tokens (< $0.01), use much larger quantities
  if (price < 0.01) {
    // For micro-priced tokens, quantities typically range from 10,000 to 100,000
    return (Math.random() * 90000 + 10000).toFixed(4);
  }
  // For low-priced tokens ($0.01-$1), use large quantities 
  else if (price < 1) {
    // For very low-priced assets, quantities typically range from 1,000 to 10,000
    return (Math.random() * 9000 + 1000).toFixed(4);
  }
  // For medium-low priced tokens ($1-$10)
  else if (price < 10) {
    // For low-priced assets, quantities typically range from 100 to 1,000
    return (Math.random() * 900 + 100).toFixed(4);
  }
  // For medium-priced assets ($10-$100), use moderate quantities
  else if (price < 100) {
    // For medium-priced assets, quantities range from 10 to 100
    return (Math.random() * 90 + 10).toFixed(4);
  }
  // For mid-high priced tokens ($100-$500) 
  else if (price < 500) {
    // Medium quantities between 0.1 and 5
    return (Math.random() * 4.9 + 0.1).toFixed(4);
  } 
  // For high-priced assets (>$500)
  else {
    // Smaller quantities between 0.05 and 2
    return (Math.random() * 1.95 + 0.05).toFixed(4);
  }
};

// Generate realistic order book data based on current price
const generateOrderBook = (currentPrice, bidAskSpread = 0.002) => {
  // Ensure we have a valid price to work with
  const validPrice = currentPrice && !isNaN(currentPrice) && currentPrice > 0 
    ? Number(currentPrice) // Ensure it's converted to a number 
    : 100;
  
  console.log('Using valid price for order book:', validPrice);
  
  // Adjust price step based on the current price to keep orders close to actual market price
  let priceStep;
  
  if (validPrice < 0.0001) {
    // For ultra-micro-priced tokens, use 0.2% of price as step
    priceStep = validPrice * 0.002;
  } else if (validPrice < 0.001) {
    // For micro-priced tokens, use 0.3% of price as step
    priceStep = validPrice * 0.003;
  } else if (validPrice < 0.01) {
    // For very low-priced tokens, use 0.4% of price as step
    priceStep = validPrice * 0.004;
  } else if (validPrice < 0.1) {
    // For low-priced tokens, use 0.5% of price as step
    priceStep = validPrice * 0.005;
  } else if (validPrice < 1) {
    // For medium-low priced tokens, use 0.2% step
    priceStep = validPrice * 0.002;
  } else {
    // For higher-priced tokens, use 0.1% step
    priceStep = validPrice * 0.001;
  }
  
  const asks = [];
  const bids = [];
  const numOrders = 8; // Reduced number of asks and bids to generate to fit without scrolling
  
  // Calculate the spread based on the actual price to ensure it's proportional
  const spreadAmount = Math.max(validPrice * 0.0005, Number.EPSILON); // Min 0.05% spread, ensure it's never 0
  
  // Calculate starting prices for asks and bids
  const askStartPrice = validPrice + (spreadAmount / 2);
  const bidStartPrice = validPrice - (spreadAmount / 2);
  
  console.log('Ask start price:', askStartPrice, 'Bid start price:', bidStartPrice, 'Step:', priceStep);
  
  // Generate ask prices (sells above current price)
  for (let i = 0; i < numOrders; i++) {
    const price = Number((askStartPrice + (i * priceStep)).toFixed(10));
    
    // Generate random volume based on price range
    const quantity = parseFloat(generateRandomQty(price));
    const total = Number((price * quantity).toFixed(10));
    
    asks.push({
      price,
      quantity,
      total
    });
  }
  
  // Generate bid prices (buys below current price)
  for (let i = 0; i < numOrders; i++) {
    // Ensure price doesn't go negative for low-priced tokens
    let price;
    if (bidStartPrice < priceStep * (i + 1)) {
      // If subtracting would make price negative, use a percentage of current price
      price = Number((bidStartPrice * Math.pow(0.99, i + 1)).toFixed(10));
    } else {
      price = Number((bidStartPrice - (i * priceStep)).toFixed(10));
    }
    
    // Ensure price is always positive
    price = Math.max(Number.EPSILON, price);
    
    // Generate random volume based on price range
    const quantity = parseFloat(generateRandomQty(price));
    const total = Number((price * quantity).toFixed(10));
    
    bids.push({
      price,
      quantity, 
      total
    });
  }
  
  // Sort asks in descending order (highest sell at top)
  asks.sort((a, b) => b.price - a.price);
  
  // Return formatted order book data
  return {
    asks,
    bids,
    marketPrice: validPrice
  };
};

// Export a single function for order book data that everyone will use
const createOrderBookData = (marketPrice, symbol, buyRatio = 0.5) => {
  if (!marketPrice || isNaN(marketPrice)) {
    console.warn('Invalid market price for order book:', marketPrice);
    return { asks: [], bids: [] };
  }

  // Log the actual market price used for debugging
  console.log('Creating order book with market price:', marketPrice);

  // Ensure we're working with the actual price, not an arbitrary value
  const validPrice = parseFloat(marketPrice);
  
  // Use very tight spread for all assets as requested
  const bidAskSpread = validPrice * 0.001; // 0.1% spread

  // Generate consistent order book data
  const orderBook = generateOrderBook(validPrice, bidAskSpread);
  
  return orderBook;
};

// Replace all existing functions with this single implementation
const generateMockOrderBookData = createOrderBookData;
const generateDummyOrders = createOrderBookData;

// Format the price displayed in the order book
const formatOrderPrice = (price) => {
  if (typeof price !== 'number' && typeof price !== 'string') {
    return '0.00';
  }
  
  const numPrice = typeof price === 'string' ? parseFloat(price) : price;
  
  if (isNaN(numPrice)) {
    return '0.00';
  }
  
  // Format based on price ranges
  if (numPrice < 0.000001) {
    // Scientific notation for extremely small prices
    return numPrice.toExponential(6);
  } else if (numPrice < 0.00001) {
    return numPrice.toFixed(9);
  } else if (numPrice < 0.0001) {
    return numPrice.toFixed(8);
  } else if (numPrice < 0.001) {
    return numPrice.toFixed(7);
  } else if (numPrice < 0.01) {
    return numPrice.toFixed(6);
  } else if (numPrice < 0.1) {
    return numPrice.toFixed(5);
  } else if (numPrice < 1) {
    return numPrice.toFixed(4);
  } else if (numPrice < 10) {
    return numPrice.toFixed(3);
  } else if (numPrice < 1000) {
    return numPrice.toFixed(2);
  } else {
    return Math.floor(numPrice).toLocaleString();
  }
};

// Helper function to safely cleanup resources
const safelyCleanup = (resource) => {
  if (resource && typeof resource === 'function') {
    try {
      resource();
    } catch (error) {
      console.error('Error during cleanup:', error);
    }
  } else if (resource && typeof resource.destroy === 'function') {
    try {
      resource.destroy();
    } catch (error) {
      console.error('Error destroying resource:', error);
    }
  } else if (resource && typeof resource.close === 'function') {
    try {
      resource.close();
    } catch (error) {
      console.error('Error closing resource:', error);
    }
  }
};

/**
 * Generates a random updated price based on the current price with realistic volatility
 * @param {number} currentPrice - The current market price
 * @returns {number} - A new price with slight random variation
 */
const getRandomUpdatedPrice = (currentPrice) => {
  if (!currentPrice || currentPrice <= 0) return 0.04;
  
  // Smaller price changes for more stable updates
  const volatilityPercentage = 0.002; // Max 0.2% change per update
  const changePercent = (Math.random() * 2 - 1) * volatilityPercentage;
  
  // Calculate new price
  let newPrice = currentPrice * (1 + changePercent);
  
  // Ensure price doesn't drop below minimum values
  if (newPrice < 0.01) {
    newPrice = Math.max(newPrice, 0.01);
  }
  
  // Round appropriately based on price magnitude
  if (newPrice < 0.1) {
    return Math.round(newPrice * 100000) / 100000;
  } else if (newPrice < 1) {
    return Math.round(newPrice * 10000) / 10000;
  } else if (newPrice < 10) {
    return Math.round(newPrice * 1000) / 1000;
  } else if (newPrice < 100) {
    return Math.round(newPrice * 100) / 100;
  }
  
  return Math.round(newPrice * 10) / 10;
};

// Add a function to play sound effect
const playTradeSound = () => {
  try {
    const audio = new Audio(soundEffect);
    audio.play().catch(error => {
      console.warn('Error playing trade sound:', error);
    });
  } catch (error) {
    console.warn('Error initializing trade sound:', error);
  }
};

// Move these styled components outside the Trading component function
const OrderPrice = styled.div`
  color: ${props => props.type === 'ask' ? 'var(--red)' : 'var(--green)'};
  font-family: 'Roboto Mono', monospace;
  
  sub {
    color: rgba(255, 255, 255, 0.5);
  }
`;

const OrderBookTable = styled.div`
  width: 100%;
  font-size: 11px;
  border: 1px solid #D4AF37;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 0 8px rgba(212, 175, 55, 0.2);
  height: 95%;
  display: flex;
  flex-direction: column;
  
  .header {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    padding: 3px 4px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    color: #666;
    font-size: 10px;
    position: sticky;
    top: 0;
    background: var(--bg2);
    z-index: 1;
  }
  
  .row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    padding: 2px 4px;
    cursor: pointer;
    transition: background 0.1s;
    
    &:hover {
      background: rgba(255, 255, 255, 0.05);
    }
  }
`;

// Restore the formatSmallNumber function since other parts of the code may be using it
const formatSmallNumber = (num) => {
  // Convert string to number if needed
  const number = typeof num === 'string' ? parseFloat(num) : num;
  
  if (isNaN(number) || number === null) return '0.00';
  
  // For extremely small numbers (less than 0.00000001)
  if (number < 0.00000001 && number > 0) {
    return '<0.00000001';
  }
  
  // For very small numbers (less than 0.0001)
  if (number < 0.0001 && number > 0) {
    // Display all significant digits for very small numbers
    const scientificNotation = number.toExponential();
    if (scientificNotation.includes('e-')) {
      // Format with appropriate decimal places based on the exponent
      const exponent = parseInt(scientificNotation.split('e-')[1], 10);
      return number.toFixed(exponent + 2).replace(/\.?0+$/, '');
    }
    return number.toFixed(8);
  }
  
  // For small numbers (0.0001 to 0.001)
  if (number < 0.001) {
    return number.toFixed(7);
  }
  
  // For numbers between 0.001 and 0.01
  if (number < 0.01) {
    return number.toFixed(6);
  }
  
  // For numbers between 0.01 and 0.1
  if (number < 0.1) {
    return number.toFixed(5);
  }
  
  // For numbers between 0.1 and 1
  if (number < 1) {
    return number.toFixed(4);
  }
  
  // For numbers between 1 and 100
  if (number < 100) {
    return number.toFixed(2);
  }
  
  // For larger numbers like Bitcoin (typically > 1000)
  // Always use toLocaleString with both minimumFractionDigits and maximumFractionDigits
  // This ensures we have proper formatting with commas AND always show .00
  return number.toLocaleString(undefined, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
};

// Add this function after formatSmallNumber but before the Trading component
const isExtremeMarketMovement = (oldPrice, newPrice, symbol = 'BTC') => {
  if (!oldPrice || !newPrice || isNaN(oldPrice) || isNaN(newPrice)) return false;
  
  // Convert to numbers to ensure proper calculation
  const oldPriceNum = parseFloat(oldPrice);
  const newPriceNum = parseFloat(newPrice);
  
  // Calculate percentage change
  const percentChange = Math.abs((newPriceNum - oldPriceNum) / oldPriceNum) * 100;
  
  // Define reasonable max percentage changes per update for different assets
  const maxPercentChanges = {
    'BTC': 2.5,    // Bitcoin is less volatile, max 2.5% in a single update
    'ETH': 3,      // Ethereum slightly more volatile
    'SOL': 5,      // Solana more volatile
    'DOGE': 7,     // Memecoin, much more volatile
    'SHIB': 10     // Small-cap, extremely volatile
  };
  
  // Get appropriate threshold or use 5% as default
  const normalizedSymbol = symbol.replace(/usdt$/i, '').toUpperCase();
  const maxChange = maxPercentChanges[normalizedSymbol] || 5;
  
  // Log large price movements for debugging
  if (percentChange > maxChange * 0.5) {
    console.warn(`Large price movement detected for ${normalizedSymbol}: ${percentChange.toFixed(2)}% change from ${oldPriceNum} to ${newPriceNum}`);
  }
  
  // Return true if movement exceeds threshold
  return percentChange > maxChange;
};

// Inside the Trading component, add these state variables at the top with other state variables
// const [lastValidatedPrice, setLastValidatedPrice] = useState(null);
// const [priceHistory, setPriceHistory] = useState([]);
// const [isPriceConsistent, setIsPriceConsistent] = useState(true);
// const [suspiciousUpdates, setSuspiciousUpdates] = useState(0);

// Trading component function
const Trading = () => {
  const { cryptoId } = useParams();
  const location = useLocation();
  const navigate = useNavigate();
  const [theme] = useState('dark');
  const { currentUser } = useAuth();
  const [cryptoData, setCryptoData] = useState(location.state?.cryptoData || null);
  const [timeframe, setTimeframe] = useState('1H');
  const [orderType, setOrderType] = useState('buy');
  const [amount, setAmount] = useState('');
  const [chartKey, setChartKey] = useState(0);
  const [orderMode, setOrderMode] = useState('market');
  const [leverage, setLeverage] = useState(1);
  const [limitPrice, setLimitPrice] = useState('');
  const [positions, setPositions] = useState({
    open: [],
    closed: []
  });
  const [userPnL, setUserPnL] = useState(0);
  const [error, setError] = useState('');
  const [currentPrice, setCurrentPrice] = useState(0);
  const [userBalance, setUserBalance] = useState(null);
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [isPending, setIsPending] = useState(false);
  const [openPositions, setOpenPositions] = useState([]);
  const [closedPositions, setClosedPositions] = useState([]);
  const [pendingLimitOrders, setPendingLimitOrders] = useState([]);
  const [inputKey, setInputKey] = useState(0);
  const [lastPrice, setLastPrice] = useState(0);
  const [marketPrice, setMarketPrice] = useState(0);
  const [closingPositionId, setClosingPositionId] = useState(null);
  const [isLoadingPositions, setIsLoadingPositions] = useState(true);
  const [isLoadingBalance, setIsLoadingBalance] = useState(true);
  const [priceData, setPriceData] = useState([]);
  const [recentTrades, setRecentTrades] = useState([]);
  const [showDebug, setShowDebug] = useState(false);
  const [buyRatio, setBuyRatio] = useState(0.5); // Default 50/50 ratio
  const [orderBookFlash, setOrderBookFlash] = useState({});
  const [orderBook, setOrderBook] = useState({ bids: [], asks: [] });
  // Price validation related states
  const [lastCheckedPrice, setLastCheckedPrice] = useState(0);
  const [ordersBeingExecuted, setOrdersBeingExecuted] = useState([]);
  const [editingOrderId, setEditingOrderId] = useState(null);
  const [editTargetPrice, setEditTargetPrice] = useState('');
  const [isPriceValidated, setIsPriceValidated] = useState(true);
  const [symbol, setSymbol] = useState('btcusdt');
  const [lastValidatedPrice, setLastValidatedPrice] = useState(null);
  const [priceHistory, setPriceHistory] = useState([]);
  const [isPriceConsistent, setIsPriceConsistent] = useState(true);
  
  // Create a ref for our price tracker to prevent recreating it on renders
  const priceTrackerRef = useRef(new PriceConsistencyTracker(currentPrice));

  // Refs for cleanup
  const ws = useRef(null);
  const priceUpdateInterval = useRef(null);
  const orderUpdateInterval = useRef(null);
  const unsubscribeOrders = useRef(null);
  const unsubscribePositions = useRef(null);

  // Use imported validation functions instead of redefining them
  const validatePrice = importedValidatePrice;
  const isExtremeMarketMovement = importedIsExtremeMovement;
  const getMedianPrice = importedGetMedianPrice;
  const calculateLiquidationPrice = importedCalculateLiquidationPrice;

  // Track price changes and update history
  const trackPrice = (newPrice, tokenSymbol) => {
    if (!newPrice || isNaN(newPrice)) return false;
    
    // Use our tracker to validate price movement
    const result = priceTrackerRef.current.trackPrice(newPrice, tokenSymbol);
    
    // Update UI state based on tracker result
    setIsPriceConsistent(priceTrackerRef.current.isDataConsistent());
    
    // If valid price, add to history
    if (result) {
      setPriceHistory(prev => [...prev, newPrice].slice(-10));
    }
    
    return result;
  };

  // Function to fetch user balances
  const fetchUserBalances = async () => {
    if (!currentUser) return;
    
    try {
      setIsLoadingBalance(true);
      const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
      
      if (userDoc.exists()) {
        const userData = userDoc.data();
        if (userData.balances) {
          setUserBalance(userData.balances);
        } else {
          // For legacy users, check the separate balances collection
          const balanceDoc = await getDoc(doc(db, 'balances', currentUser.uid));
          if (balanceDoc.exists()) {
            setUserBalance(balanceDoc.data());
          }
        }
        }
      } catch (error) {
      console.error('Error fetching user balances:', error);
    } finally {
      setIsLoadingBalance(false);
    }
  };

  // Function to fetch pending limit orders for the current symbol
  const fetchPendingLimitOrders = useCallback(async () => {
    if (!currentUser || !cryptoData?.token?.symbol) return;
    
    try {
      console.log('Fetching pending limit orders for:', currentUser.uid, cryptoData?.token?.symbol);
      const limitOrders = await tradingService.getLimitOrders(currentUser.uid, cryptoData?.token?.symbol);
      console.log('Received limit orders:', limitOrders);
      setPendingLimitOrders(limitOrders);
        } catch (error) {
      console.error('Error fetching limit orders:', error);
    }
  }, [currentUser, cryptoData?.token?.symbol]);

  // Function to fetch positions
  const fetchPositions = useCallback(async () => {
    if (!currentUser) return;
    
    try {
      setIsLoadingPositions(true);
      
      // Query for open positions
      const openPositionsQuery = query(
        collection(db, 'positions'),
        where('userId', '==', currentUser.uid),
        where('status', '==', 'OPEN')
      );
      
      // Fetch both open positions
      const openPositionsSnapshot = await getDocs(openPositionsQuery);
      const openPositionsData = openPositionsSnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      
      // Set the positions
      setOpenPositions(openPositionsData);
    } catch (error) {
      console.error('Error fetching positions:', error);
    } finally {
      setIsLoadingPositions(false);
    }
  }, [currentUser]);

  // Effect to fetch positions on mount and when user changes
  useEffect(() => {
    if (currentUser) {
      fetchPositions();
      fetchPendingLimitOrders(); // Also fetch pending limit orders when user changes
    }
  }, [currentUser]);

  // Move ensureUserBalances here, at the top level of the component
  const ensureUserBalances = useCallback(async () => {
    if (!currentUser) return;
    
    try {
      // Check if user has balances field
      const userRef = doc(db, 'users', currentUser.uid);
      const userDoc = await getDoc(userRef);
      
      if (userDoc.exists()) {
        const userData = userDoc.data();
        
        // If balances field doesn't exist or is invalid, create it
        if (!userData.balances || typeof userData.balances !== 'object') {
          console.log('User missing balances field, adding default balances');
          
          // Try to get any existing balances from the old location
          let existingBalances = { USDT: 1000 }; // Default to 1000 USDT
          
          try {
            const oldBalanceDoc = await getDoc(doc(db, 'balances', currentUser.uid));
            if (oldBalanceDoc.exists()) {
              const oldBalances = oldBalanceDoc.data();
              if (oldBalances.USDT !== undefined) {
                existingBalances.USDT = oldBalances.USDT;
              }
              if (oldBalances.BTC !== undefined) {
                existingBalances.BTC = oldBalances.BTC;
              }
              // Add other coins as needed
    }
  } catch (error) {
            console.warn('Error fetching old balances:', error);
          }
          
          // Update user document with balances
          await updateDoc(userRef, {
            balances: existingBalances
          });
          
          console.log('Updated user with balances:', existingBalances);
        }
      }
    } catch (error) {
      console.error('Error ensuring user balances:', error);
    }
  }, [currentUser]);
  
  // Call the ensureUserBalances function when component mounts and user is available
  useEffect(() => {
    if (currentUser) {
      ensureUserBalances();
    }
  }, [currentUser, ensureUserBalances]);

  // WebSocket setup
  const setupWebSocket = useCallback(() => {
    if (!isOnline) return null;

    try {
      // Close existing connection if any
      if (ws.current) {
        ws.current.close();
      }

      const symbol = cryptoData?.token?.symbol?.toLowerCase() || 'btc';
      const wsSymbol = `${symbol}usdt@ticker`;
      const newWs = new WebSocket(`wss://stream.binance.com:9443/ws/${wsSymbol}`);
      
      newWs.onopen = () => {
        console.log('WebSocket connected');
      };

      newWs.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          // Handle the message data
          console.log('WebSocket message:', data);
        } catch (error) {
          console.error('Error processing WebSocket message:', error);
        }
      };

      newWs.onerror = (error) => {
        console.error('WebSocket error:', error);
      };

      newWs.onclose = () => {
        console.log('WebSocket disconnected');
      };

      ws.current = newWs;
      return () => {
        if (ws.current) {
          ws.current.close();
          ws.current = null;
        }
      };
    } catch (error) {
      console.error('Error setting up WebSocket:', error);
      return null;
    }
  }, [isOnline, cryptoData?.token?.symbol]);

  // Price update function
  const updatePrice = useCallback(async () => {
    try {
      // Your price update logic here
      const newPrice = currentPrice * (1 + (Math.random() - 0.5) * 0.001);
      setCurrentPrice(newPrice);
      
      // Also update market price for limit order checking
      setMarketPrice(newPrice.toLocaleString());
      
      console.log(`ðŸ’° PRICE UPDATE: ${newPrice.toLocaleString()} USDT`);
      
      // If we have pending limit orders, log that we're checking them with the new price
      if (pendingLimitOrders.length > 0) {
        console.log(`ðŸ’° Checking ${pendingLimitOrders.length} pending orders with new price: ${newPrice.toLocaleString()}`);
      }
    } catch (error) {
      console.error('Error updating price:', error);
    }
  }, [currentPrice, pendingLimitOrders.length]);

  // Cleanup effect
  useEffect(() => {
    return () => {
      // Cleanup WebSocket
      if (ws.current) {
        ws.current.close();
        ws.current = null;
      }

      // Clear intervals
      if (priceUpdateInterval.current) {
        clearInterval(priceUpdateInterval.current);
        priceUpdateInterval.current = null;
      }

      // Clear any other intervals or timeouts
      if (orderUpdateInterval.current) {
        clearInterval(orderUpdateInterval.current);
        orderUpdateInterval.current = null;
      }

      // Unsubscribe from any Firestore listeners
      if (typeof unsubscribeOrders.current === 'function') {
        unsubscribeOrders.current();
      }
      if (typeof unsubscribePositions.current === 'function') {
        unsubscribePositions.current();
      }
    };
  }, []);

  // WebSocket connection effect
  useEffect(() => {
    const cleanup = setupWebSocket();
    return () => {
      if (cleanup && typeof cleanup === 'function') {
        cleanup();
      }
    };
  }, [setupWebSocket]);

  // Price update interval effect
  useEffect(() => {
    const intervalId = setInterval(updatePrice, 5000);
    priceUpdateInterval.current = intervalId;
    
    return () => {
      clearInterval(intervalId);
      priceUpdateInterval.current = null;
    };
  }, [updatePrice]);

  // Order update interval effect
  useEffect(() => {
    const intervalId = setInterval(() => {
      setOrderBook(generateMockOrderBookData(currentPrice));
    }, 3000);
    orderUpdateInterval.current = intervalId;
    
    return () => {
      clearInterval(intervalId);
      orderUpdateInterval.current = null;
    };
  }, [currentPrice]);

  // TradingView widget cleanup
  useEffect(() => {
    const tradingViewContainer = document.getElementById('tradingview_chart');
    
    return () => {
      try {
        if (tradingViewContainer) {
          while (tradingViewContainer.firstChild) {
            tradingViewContainer.removeChild(tradingViewContainer.firstChild);
          }
        }
        
        if (window.TradingView && typeof window.TradingView === 'object') {
          if (window.TradingView._binders) {
            window.TradingView._binders = [];
          }
        }
      } catch (error) {
        console.error('Error cleaning up TradingView widget:', error);
      }
    };
  }, []);

  // Order book interval management
  useEffect(() => {
    let orderBookInterval = null;
    
    if (isOnline) {
      orderBookInterval = setInterval(() => {
        try {
          if (marketPrice) {
            const newOrders = generateDummyOrders(marketPrice);
            setOrderBook(newOrders);
            
            const newBuyRatio = Math.floor(Math.random() * 40) + 10;
            setBuyRatio(newBuyRatio);
            
            const newFlash = {};
            newOrders.asks.forEach((_, i) => {
              if (Math.random() > 0.7) {
                newFlash[`ask-${i}`] = true;
              }
            });
            
            newOrders.bids.forEach((_, i) => {
              if (Math.random() > 0.7) {
                newFlash[`bid-${i}`] = true;
              }
            });
            
            setOrderBookFlash(newFlash);
            
            setTimeout(() => {
              setOrderBookFlash({});
            }, 600);
          }
        } catch (error) {
          console.error('Error updating order book:', error);
        }
      }, 4000);
    }
    
    return () => {
      if (orderBookInterval) {
        clearInterval(orderBookInterval);
      }
    };
  }, [marketPrice, isOnline]);

  // Effect for online/offline status
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // Add a price validation function to detect anomalies
  const validatePrice = (price, symbol = 'BTC') => {
    if (!price || isNaN(price) || price <= 0) return false;
    
    // Define reasonable price ranges for common cryptocurrencies
    const priceRanges = {
      'BTC': { min: 10000, max: 200000 },    // Bitcoin reasonable range $10k-$200k
      'ETH': { min: 500, max: 20000 },       // Ethereum reasonable range $500-$20k
      'BNB': { min: 50, max: 2000 },         // Binance Coin reasonable range $50-$2k
      'SOL': { min: 10, max: 1000 },         // Solana reasonable range $10-$1k
      'XRP': { min: 0.1, max: 10 },          // Ripple reasonable range $0.1-$10
      'ADA': { min: 0.05, max: 10 },         // Cardano reasonable range $0.05-$10
      'DOGE': { min: 0.001, max: 5 },        // Dogecoin reasonable range $0.001-$5
      'SHIB': { min: 0.000001, max: 0.01 }   // Shiba Inu reasonable range $0.000001-$0.01
    };
    
    // Default reasonable range for other coins
    const defaultRange = { min: 0.0001, max: 500000 };
    
    // Get the appropriate range based on symbol
    const normalizedSymbol = symbol.replace(/usdt$/i, '').toUpperCase();
    const range = priceRanges[normalizedSymbol] || defaultRange;
    
    // Check if price is within reasonable range
    return price >= range.min && price <= range.max;
  };

  // Effect for price updates
  useEffect(() => {
    if (!cryptoData) return;

    let ws;
    let lastValidPrice = null; // Track the last known valid price
    
    const updatePrice = async () => {
      if (cryptoData?.token?.type === 'dex') {
        // DEX price update logic
        if (cryptoData?.token?.address && cryptoData?.token?.chainId) {
          try {
            const response = await axios.get(`https://api.dexscreener.com/latest/dex/pairs/${cryptoData.token.chainId}/${cryptoData.token.address}`);
            if (response.data?.pair?.priceUsd) {
              const price = parseFloat(response.data.pair.priceUsd);
              console.log('Raw DEX price from API:', price);
              
              const symbol = cryptoData?.token?.symbol?.toUpperCase() || 'BTC';
              const isValidPrice = validatePrice(price, symbol);
              
              // Update validation state
              setIsPriceValidated(isValidPrice);
              
              if (!isNaN(price) && price > 0 && isValidPrice) {
                // Store the exact price from the API
                lastValidPrice = price;
                setMarketPrice(price);
                setLastPrice(price);
                setCurrentPrice(price);
                
                // Generate order book with exactly the same price
                console.log('Generating order book with exact DEX price:', price);
                const newOrderBook = generateDummyOrders(price);
                setOrderBook(newOrderBook);
              } else {
                console.warn('Anomalous price detected from DEX API:', price);
                // Use last valid price if available, otherwise don't update
                if (lastValidPrice) {
                  console.log('Using last valid price instead:', lastValidPrice);
                  setMarketPrice(lastValidPrice);
                  setLastPrice(lastValidPrice);
                  setCurrentPrice(lastValidPrice);
                }
              }
            }
          } catch (error) {
            console.error('Error fetching DEX price:', error);
          }
        }
      } else {
        // Use CoinGecko API for reliable CEX prices
        try {
          const symbol = cryptoData?.token?.symbol?.toLowerCase() || 'btc';
          let coinId;
          
          // Map symbols to CoinGecko IDs
          switch (symbol) {
            case 'btc':
            case 'btcusdt':
              coinId = 'bitcoin';
              break;
            case 'eth':
            case 'ethusdt':
              coinId = 'ethereum';
              break;
            default:
              // Try to use symbol as coinId for other tokens
              coinId = symbol.replace('usdt', '');
          }
          
          console.log(`Fetching price for ${coinId} from CoinGecko`);
          const response = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`);
          
          if (response.data[coinId] && response.data[coinId].usd) {
            const newPrice = parseFloat(response.data[coinId].usd);
            console.log('Raw price from CoinGecko:', newPrice);
            
            const normalizedSymbol = symbol.replace(/usdt$/i, '').toUpperCase();
            const isValidPrice = validatePrice(newPrice, normalizedSymbol);
            
            // Update validation state
            setIsPriceValidated(isValidPrice);
            
            if (!isNaN(newPrice) && newPrice > 0 && isValidPrice) {
              console.log(`Received price update for ${coinId}:`, newPrice);
              lastValidPrice = newPrice;
              setMarketPrice(newPrice);
              setLastPrice(newPrice);
              setCurrentPrice(newPrice);
              
              // Generate order book with the exact same price
              console.log('Generating order book with exact price:', newPrice);
              const newOrderBook = generateDummyOrders(newPrice);
              setOrderBook(newOrderBook);
              
              // Also set up a WebSocket for real-time updates if available
              setupWebSocketConnection(symbol.toLowerCase());
            } else {
              console.warn('Anomalous price detected from CoinGecko:', newPrice);
              // Use last valid price if available, otherwise don't update
              if (lastValidPrice) {
                console.log('Using last valid price instead:', lastValidPrice);
                setMarketPrice(lastValidPrice);
                setLastPrice(lastValidPrice);
                setCurrentPrice(lastValidPrice);
              }
            }
          } else {
            console.warn('Failed to get price from CoinGecko, falling back to Binance WebSocket');
            setupWebSocketConnection(symbol.toLowerCase());
          }
        } catch (error) {
          console.error('Error fetching price from CoinGecko:', error);
          
          // Fallback to Binance WebSocket
        const symbol = cryptoData?.token?.symbol?.toLowerCase() || 'btcusdt';
          setupWebSocketConnection(symbol.toLowerCase());
        }
      }
    };
    
    const setupWebSocketConnection = (symbol) => {
      // Ensure symbol has usdt suffix
      const formattedSymbol = symbol.endsWith('usdt') ? symbol : `${symbol}usdt`;
      
      console.log('Setting up WebSocket for symbol:', formattedSymbol);
      
      // Close existing connection
      if (ws) {
        ws.close();
      }
      
      // Create new connection
      ws = new WebSocket(`wss://stream.binance.com:9443/ws/${formattedSymbol}@trade`);
        
        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.p) {
              const newPrice = parseFloat(data.p);
              
              const normalizedSymbol = symbol.replace(/usdt$/i, '').toUpperCase();
              const isValidPrice = validatePrice(newPrice, normalizedSymbol);
              
              // Add price movement validation - track this price if valid
              const isPriceMovementValid = trackPrice(newPrice, normalizedSymbol);
              
              if (!isNaN(newPrice) && newPrice > 0 && isValidPrice && isPriceMovementValid) {
                console.log(`Received WebSocket price update for ${formattedSymbol}:`, newPrice);
                // Use exactly the same price for all state updates
                lastValidPrice = newPrice;
                setLastValidatedPrice(newPrice);
                setMarketPrice(newPrice);
                setLastPrice(newPrice);
                setCurrentPrice(newPrice);
                
                // Generate order book with the exact same price
                console.log('Generating order book with exact WebSocket price:', newPrice);
                const newOrderBook = generateDummyOrders(newPrice);
                setOrderBook(newOrderBook);
              } else {
                console.warn('Anomalous price received from WebSocket:', data.p);
                // Use last valid price if available, otherwise don't update
                if (lastValidPrice) {
                  console.log('Using last valid price instead:', lastValidPrice);
                  // Don't update prices on suspicious updates, just maintain the last valid one
                }
              }
      }
    } catch (error) {
            console.error('Error processing WebSocket message:', error);
          }
        };

        ws.onerror = (error) => {
          console.error('WebSocket error:', error);
        };
      
      ws.onclose = () => {
        console.log('WebSocket connection closed');
      };
    };

    // Initialize price update
    updatePrice();

    // Set up periodic updates every 30 seconds as a fallback
    const interval = setInterval(updatePrice, 30000);

    return () => {
      if (ws) {
        ws.close();
      }
        clearInterval(interval);
    };
  }, [cryptoData]);

  // Define fetchUserData function before it's used in any useEffect
  const fetchUserData = useCallback(async () => {
    if (!currentUser) return () => {};  // Return empty cleanup function
    
    try {
      // Listen to user balance changes
      const userUnsubscribe = onSnapshot(
        doc(db, 'users', currentUser.uid),
        {
          includeMetadataChanges: true
        },
        (doc) => {
          if (doc.exists()) {
            const userData = doc.data();
            console.log('Full user data:', userData);
            
            // Check if balances exist in the user document
            if (userData.balances) {
              console.log('User balances from document:', userData.balances);
              console.log('USDT balance type:', typeof userData.balances.USDT, 'value:', userData.balances.USDT);
              
              // Ensure USDT exists and is a valid number
              if (userData.balances.USDT === undefined || userData.balances.USDT === null || isNaN(userData.balances.USDT)) {
                console.warn('Invalid USDT balance in user document, setting to 0');
                userData.balances.USDT = 0;
              }
              
              setUserBalance(userData.balances);
            } else {
              // No balances in user document
              console.warn('No balances field in user document, will be fixed by ensureUserBalances');
              setUserBalance({ USDT: 0, BTC: 0, ETH: 0 });
            }
            
            setIsLoadingBalance(false);
          }
        },
        (error) => console.error('User snapshot error:', error)
      );

      // Listen to positions
      const positionsUnsubscribe = onSnapshot(
        query(collection(db, 'positions'), where('userId', '==', currentUser.uid)),
        {
          includeMetadataChanges: true
        },
        (snapshot) => {
          const openPos = [];
          const closedPos = [];
          
          snapshot.docs.forEach(doc => {
            const data = doc.data();
            const position = {
        id: doc.id,
              ...data,
              openTime: data.openTime?.toDate?.() || new Date(data.openTime),
              closeTime: data.closeTime?.toDate?.() || (data.closeTime ? new Date(data.closeTime) : null),
              lastUpdated: data.lastUpdated?.toDate?.() || new Date(data.lastUpdated)
            };

            if (position.status === 'OPEN') {
              openPos.push(position);
            } else if (position.status === 'CLOSED') {
              closedPos.push(position);
            }
          });

          setOpenPositions(openPos.sort((a, b) => b.openTime - a.openTime));
          setClosedPositions(closedPos.sort((a, b) => b.closeTime - a.closeTime));
      setIsLoadingPositions(false);
        },
        (error) => console.error('Positions snapshot error:', error)
      );

      // Return a cleanup function that calls both unsubscribe functions
      return () => {
        userUnsubscribe();
        positionsUnsubscribe();
      };
    } catch (error) {
      console.error('Error in fetchUserData:', error);
      return () => {}; // Return empty cleanup function
    }
  }, [currentUser]);

  // Define fetchPriceData function before any useEffect that uses it
  const fetchPriceData = useCallback(async () => {
    if (!cryptoData?.token) {
      console.warn('No token data available for fetchPriceData');
      return;
    }

    try {
      if (cryptoData.token.type === 'dex') {
        // For DEX tokens, use DexScreener API's standard pairs endpoint
        const chain = cryptoData.token.chainId?.toLowerCase() || 'ethereum';
        const pairAddress = cryptoData.pairInfo?.address?.toLowerCase();
        
        if (!pairAddress) {
          console.error('No pair address available for DEX token');
          setPriceData([]);
          return;
        }
        
        console.log(`Fetching price data for ${chain}/${pairAddress}`);
        
        // Try both format options to ensure we get data
        let response;
        try {
          // First attempt: Use pairs/{chain}/{pairAddress} format
          response = await axios.get(
            `https://api.dexscreener.com/latest/dex/pairs/${chain}/${pairAddress}`
          );
          console.log('DexScreener API response (pairs endpoint):', response.data);
        } catch (error) {
          console.error('Error fetching from DexScreener pairs endpoint:', error);
          
          // Second attempt: Use direct address endpoint
          try {
            response = await axios.get(
              `https://api.dexscreener.com/latest/dex/search?q=${pairAddress}`
            );
            console.log('DexScreener API response (search endpoint):', response.data);
          } catch (searchError) {
            console.error('Error fetching from DexScreener search endpoint:', searchError);
            throw new Error('Failed to fetch data from DexScreener');
          }
        }
        
        // Check if we have valid data from either attempt
        const pairs = response.data?.pairs || [response.data?.pair].filter(Boolean);
        if (pairs && pairs.length > 0) {
          const pair = pairs[0];
          console.log('Found pair data:', pair);
          
          // Update market price with the latest price
          if (pair.priceUsd) {
            const priceUsd = Number(parseFloat(pair.priceUsd));
            if (!isNaN(priceUsd) && priceUsd > 0) {
              setMarketPrice(priceUsd);
              setCurrentPrice(priceUsd);
            } else {
              console.warn('Invalid price from DexScreener:', pair.priceUsd);
            }
          }
          
          // Update pairInfo with any additional data we got from DexScreener
          if (!cryptoData.pairInfo || !cryptoData.pairInfo.dexId) {
            const updatedCryptoData = {
              ...cryptoData,
              pairInfo: {
                ...cryptoData.pairInfo,
                address: pair.pairAddress || cryptoData.pairInfo?.address,
                dexId: pair.dexId || cryptoData.pairInfo?.dexId || 'unknown',
                baseToken: pair.baseToken || cryptoData.pairInfo?.baseToken,
                quoteToken: pair.quoteToken || cryptoData.pairInfo?.quoteToken,
                priceUsd: pair.priceUsd || cryptoData.pairInfo?.priceUsd
              }
            };
            setCryptoData(updatedCryptoData);
            console.log('Updated cryptoData with pair info:', updatedCryptoData);
          }
          
          // For price history, we need to create a simple dataset
          // DexScreener doesn't provide candlestick data through this endpoint
          
          // Create a minimal dataset with the current price
          const currentTime = Math.floor(Date.now() / 1000);
          
          // Use priceChange data if available to estimate an "open" price
          const priceChangeH24 = pair.priceChange?.h24 ? parseFloat(pair.priceChange.h24) : 0;
          const closePrice = parseFloat(pair.priceUsd || 0);
          const openPrice = closePrice / (1 + (priceChangeH24 / 100));
          
          // Estimate high and low based on price change
          const priceChange = Math.abs(closePrice - openPrice);
          const high = Math.max(openPrice, closePrice) + (priceChange * 0.1); // Add 10% buffer
          const low = Math.min(openPrice, closePrice) - (priceChange * 0.1);  // Subtract 10% buffer
          
          // Create a simple dataset for the chart
          setPriceData([{
            time: currentTime,
            open: openPrice,
            high: high,
            low: low,
            close: closePrice,
            volume: parseFloat(pair.volume?.h24 || 0)
          }]);
          
          console.log('Created simplified price data for chart');
        } else {
          // No valid pair data
          console.error('No valid pair data found for', pairAddress);
          console.log('Full response:', response.data);
          setPriceData([]);
        }
      } else {
        // For CEX tokens, use existing Binance API
        const interval = TIMEFRAMES[timeframe].binanceInterval;
        const symbol = `${cryptoData.token.symbol}USDT`;

        const response = await axios.get(
          `https://api.binance.com/api/v3/klines`,
          {
            params: {
              symbol: symbol,
              interval: interval,
              limit: 500
            }
          }
        );

        const formattedData = response.data.map(candle => ({
          time: candle[0] / 1000,
          open: parseFloat(candle[1]),
          high: parseFloat(candle[2]),
          low: parseFloat(candle[3]),
          close: parseFloat(candle[4]),
          volume: parseFloat(candle[5])
        }));

        setPriceData(formattedData);
      }
    } catch (error) {
      console.error('Error fetching price data:', error);
      setPriceData([]);
    }
  }, [cryptoData?.token?.id, cryptoData?.token?.type, cryptoData?.pairInfo?.address, timeframe]);

  // Update user data useEffect
  useEffect(() => {
    if (currentUser) {
      return fetchUserData();
    }
  }, [currentUser, fetchUserData]);

  // Update price data useEffect
  useEffect(() => {
    // Always call the hook, but conditionally run the logic inside
    if (cryptoData?.token?.id) {
      fetchPriceData();
    }
  }, [cryptoData?.token?.id, fetchPriceData]);

  // Improved market price update effect - always call this hook unconditionally
  useEffect(() => {
    // Move the conditional logic inside the effect but always call the hook
    const updateMarketPriceFromCryptoData = () => {
      let priceToUse = null;
      
      // Try to get price from different sources in priority order
      if (cryptoData?.token?.price && !isNaN(parseFloat(cryptoData.token.price))) {
        priceToUse = parseFloat(cryptoData.token.price);
        console.log('ðŸ“Š Using token price:', priceToUse);
      } else if (cryptoData?.chartData?.price && !isNaN(parseFloat(cryptoData.chartData.price))) {
        priceToUse = parseFloat(cryptoData.chartData.price);
        console.log('ðŸ“Š Using chart price:', priceToUse);
      } else if (cryptoData?.lastPrice && !isNaN(parseFloat(cryptoData.lastPrice))) {
        priceToUse = parseFloat(cryptoData.lastPrice);
        console.log('ðŸ“Š Using last price:', priceToUse);
      }
      
      // If we found a valid price, update market price and order book
      if (priceToUse !== null && priceToUse > 0) {
        // Ensure the price is a valid number
        priceToUse = Number(priceToUse);
        setMarketPrice(priceToUse);
        
        // Generate a new order book with the updated price
        const newOrderBook = generateOrderBook(priceToUse);
        setOrderBook(newOrderBook);
        
        // Check limit orders immediately whenever price updates
        if (pendingLimitOrders.length > 0) {
          console.log('ðŸ“Š Price updated, checking pending orders...');
          checkPendingLimitOrders();
        }
      } else {
        console.warn('No valid price found in crypto data:', cryptoData);
      }
    };
    
    // Always call this function, whether cryptoData exists or not
    updateMarketPriceFromCryptoData();
    
  }, [cryptoData, pendingLimitOrders.length]);

  // Update the chart initialization useEffect
  useEffect(() => {
    if (!priceData.length) return;

    const handleResize = () => {
      // Handle chart resize logic
    };

    try {
      // Create chart instance with IChartApi type
      // const chartInstance = createChart(chartContainerRef.current, {
      //   width: chartContainerRef.current.clientWidth,
      //   height: chartContainerRef.current.clientHeight,
      //   layout: {
      //     background: { type: ColorType.Solid, color: '#1E222D' },
      //     textColor: '#7a7a7a',
      //   },
      //   grid: {
      //     vertLines: { color: 'rgba(42, 46, 57, 0.2)' },
      //     horzLines: { color: 'rgba(42, 46, 57, 0.2)' },
      //   },
      //   timeScale: {
      //     timeVisible: true,
      //     secondsVisible: false,
      //     borderColor: 'rgba(42, 46, 57, 0.5)',
      //   },
      //   rightPriceScale: {
      //     borderColor: 'rgba(42, 46, 57, 0.5)',
      //   },
      //   crosshair: {
      //     mode: 1,
      //     vertLine: {
      //       color: '#758696',
      //       width: 1,
      //       style: 3,
      //     },
      //     horzLine: {
      //       color: '#758696',
      //       width: 1,
      //       style: 3,
      //     },
      //   },
      // });

      // // Create candlestick series with proper type
      // const mainSeries = chartInstance.addCandlestickSeries({
      //   upColor: '#0ECB81',
      //   downColor: '#F6465D',
      //   borderUpColor: '#0ECB81',
      //   borderDownColor: '#F6465D',
      //   wickUpColor: '#0ECB81',
      //   wickDownColor: '#F6465D',
      // });

      // // Create volume series with proper type
      // const volumeSeries = chartInstance.addHistogramSeries({
      //   color: '#26a69a',
      //   priceFormat: {
      //     type: 'volume',
      //   },
      //   priceScaleId: '', // Set as overlay
      //   scaleMargins: {
      //     top: 0.8,
      //     bottom: 0,
      //   },
      // });

      // // Format data for candlestick series
      // const candleData = priceData.map(d => ({
      //   time: d.time,
      //   open: d.open,
      //   high: d.high,
      //   low: d.low,
      //   close: d.close,
      // }));

      // // Format data for volume series
      // const volumeData = priceData.map(d => ({
      //   time: d.time,
      //   value: d.volume,
      //   color: d.close > d.open ? 'rgba(14, 203, 129, 0.3)' : 'rgba(246, 70, 93, 0.3)',
      // }));

      // // Set data to series
      // mainSeries.setData(candleData);
      // volumeSeries.setData(volumeData);

      // // Fit content
      // chartInstance.timeScale().fitContent();

      // // Save chart reference
      // chartRef.current = chartInstance;

      // // Add resize listener
      // window.addEventListener('resize', handleResize);

      // // Cleanup
      // return () => {
      //   window.removeEventListener('resize', handleResize);
      //   if (chartRef.current) {
      //     chartRef.current.remove();
      //     chartRef.current = null;
      //   }
      // };
    } catch (error) {
      console.error('Error creating chart:', error);
    }
  }, [priceData]);

  // Fetch data when timeframe changes
  useEffect(() => {
    fetchPriceData();
  }, [timeframe, cryptoData?.token?.id, fetchPriceData]); // Add fetchPriceData as a dependency

  // Function to handle canceling a limit order
  const handleCancelLimitOrder = async (orderId) => {
    if (isPending) return;
    
    try {
    setIsPending(true);
      await tradingService.cancelLimitOrder(currentUser.uid, orderId);
      setIsPending(false);
      
      // Refresh the list of limit orders
      fetchPendingLimitOrders();
      
      // Show success message
      console.log('Limit order canceled successfully');
    } catch (error) {
      console.error('Error canceling limit order:', error);
      setError(error.message || 'Failed to cancel limit order');
      setIsPending(false);
    }
  };

  // Update the handleSubmit function
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Prevent trading if price is invalid
    if (!isPriceValidated) {
      addNotification({
        title: 'Price Error',
        message: 'Cannot execute trade with invalid price data. Please wait for accurate pricing.',
        type: 'error',
        playSound: true
      });
      return;
    }

    if (!currentUser) {
      addNotification({
        title: 'Authentication Required',
        message: 'Please log in to place trades',
        type: 'error'
      });
      return;
    }

    if (isPending) return;

    const tradeAmount = parseFloat(amount);
    const currentMarketPrice = orderMode === 'market' ? marketPrice : parseFloat(limitPrice);
    
    // Validate market price before proceeding
    const symbol = cryptoData?.token?.symbol?.toUpperCase() || 'BTC';
    const isValidPrice = validatePrice(currentMarketPrice, symbol);
    
    if (!isValidPrice) {
      console.error('Cannot execute trade: price appears to be anomalous:', currentMarketPrice);
      setError(`Cannot execute trade: ${symbol} price (${currentMarketPrice}) appears to be incorrect. Please wait for accurate price data.`);
      return;
    }
    
    const requiredMargin = calculateRequiredMargin(tradeAmount, currentMarketPrice, leverage);

    if (!tradeAmount || !currentMarketPrice || !leverage) {
      setError('Please fill in all fields');
      return;
    }

    if (userBalance?.USDT < requiredMargin) {
      setError('Insufficient balance');
      return;
    }

    const tradeData = {
      symbol: cryptoData.token.symbol,
      type: orderType,      // Use the current order type
      side: orderType,      // Use the current order type for side 
      amount: tradeAmount,
      leverage: parseInt(leverage),
      entryPrice: currentMarketPrice,
      margin: requiredMargin,
      orderMode: orderMode
    };

    // For limit orders, add the target price
    if (orderMode === 'limit') {
      tradeData.targetPrice = parseFloat(limitPrice);
    }

    try {
      setError('');
      setIsPending(true);
      
      if (orderMode === 'market') {
        // For market orders, use the existing optimistic update approach
        // ---------------------------
        // Optimistic Update Start
        // ---------------------------
        const provisionalId = `temp-${Date.now()}`;
        const now = new Date();
        const provisionalPosition = {
          id: provisionalId,
          userId: currentUser.uid,
          symbol: tradeData.symbol,
          type: tradeData.type,
          side: tradeData.side,   // Add side field to the position
          amount: tradeData.amount,
          leverage: tradeData.leverage,
          entryPrice: tradeData.entryPrice,
          margin: tradeData.margin,
          orderMode: tradeData.orderMode,
          status: 'OPEN',
          openTime: now,
          currentPnL: 0,
          lastUpdated: now,
          closePrice: null,
          closeTime: null,
          finalPnL: null
        };

        setOpenPositions(prev => [provisionalPosition, ...prev]);
        
        const result = await tradingService.openPosition(currentUser.uid, tradeData);
        
        if (!result.success) {
          // Roll back optimistic update in case of error
          setOpenPositions(prev => prev.filter(p => p.id !== provisionalId));
          throw new Error(result.error || 'Failed to create position');
        } else {
          // Play sound effect on successful trade execution
          playTradeSound();
        }
      } else if (orderMode === 'limit') {
        // For limit orders, create a provisional pending order for UI feedback
        console.log('===== CREATING LIMIT ORDER =====');
        console.log('Order data:', tradeData);
        
        const provisionalId = `temp-${Date.now()}`;
        const now = new Date();
        
        // Ensure we're using the right field names consistently
        const provisionalOrder = {
          id: provisionalId,
          userId: currentUser.uid,
          symbol: tradeData.symbol,
          // Explicitly set both type and side for consistency
          type: tradeData.type,
          side: tradeData.side, // Add side field with same value as type
          amount: tradeData.amount,
          leverage: tradeData.leverage,
          targetPrice: tradeData.entryPrice,
          price: tradeData.entryPrice, // Add price field with same value as targetPrice
          margin: tradeData.margin,
          status: 'PENDING',
          createdAt: now,
          lastUpdated: now,
          isProvisional: true // Flag to identify optimistic updates
        };
        
        console.log('Provisional limit order:', provisionalOrder);
        
        // Optimistically add to pending limit orders
        setPendingLimitOrders(prev => [provisionalOrder, ...prev]);
        
        const result = await tradingService.createLimitOrder(currentUser.uid, tradeData);
        console.log('Limit order creation result:', result);
        
        if (!result.success) {
          // Remove provisional order on error
          setPendingLimitOrders(prev => 
            prev.filter(order => !order.isProvisional)
          );
          throw new Error(result.error || 'Failed to create limit order');
        } else {
          // Don't play sound for limit orders since they're not executed immediately
          console.log('Limit order created successfully');
        }
        
        // Refresh the actual limit orders from the server
        fetchPendingLimitOrders();
      }
    } catch (error) {
      console.error('Error creating position/order:', error);
      setError(error.message || 'Failed to create position/order');
    } finally {
      setIsPending(false);
      // Clear input fields whether success or error
      setAmount('');
      setLeverage(1);
      setLimitPrice('');
    }
  };

  // Add the handleClosePosition function
  const handleClosePosition = async (position) => {
    if (isPending) return;
    
    try {
      console.log('Closing position:', position);
      setError('');
      setIsPending(true);
      setClosingPositionId(position.id);
      
      // Parse and ensure market price is a proper number
      const currentMarketPrice = parseFloat(marketPrice);
      
      if (isNaN(currentMarketPrice) || currentMarketPrice <= 0) {
        console.error('Invalid market price for closing position:', marketPrice);
        throw new Error('Cannot close position: Invalid market price');
      }
      
      // Validate market price is reasonable for this token
      const symbol = position.symbol?.toUpperCase() || cryptoData?.token?.symbol?.toUpperCase() || 'BTC';
      const isValidPrice = validatePrice(currentMarketPrice, symbol);
      
      if (!isValidPrice) {
        console.error('Price appears anomalous for closing position:', currentMarketPrice);
        throw new Error(`Cannot close position: The current price (${currentMarketPrice}) appears incorrect for ${symbol}`);
      }
      
      // Calculate a median price if we have price history
      let medianPrice = null;
      if (priceHistory && priceHistory.length > 0) {
        const sortedPrices = [...priceHistory].sort((a, b) => a - b);
        const mid = Math.floor(sortedPrices.length / 2);
        medianPrice = sortedPrices.length % 2 === 0 
          ? (sortedPrices[mid - 1] + sortedPrices[mid]) / 2
          : sortedPrices[mid];
      }
      
      // Use median price if available for stability, otherwise use current price
      const priceToUse = medianPrice || currentMarketPrice;
      
      // Safety check: warn user if closing price differs significantly from entry price
      const entryPriceNum = parseFloat(position.entryPrice);
      const priceDiffPercent = Math.abs((priceToUse - entryPriceNum) / entryPriceNum * 100);
      
      if (priceDiffPercent > 15) {
        // For large differences, show a confirmation dialog
        const shouldProceed = window.confirm(
          `Warning: This position will be closed at a price that is ${priceDiffPercent.toFixed(2)}% different from your entry price. Are you sure you want to continue?`
        );
        
        if (!shouldProceed) {
          setIsPending(false);
          setClosingPositionId(null);
          throw new Error('Position close cancelled by user');
        }
      }
      
      console.log(`Attempting to close position ${position.id} at price $${priceToUse}`);
      
      // Pass the currentUser.uid as the first parameter with the properly formatted price
      const result = await tradingService.closePosition(currentUser.uid, position.id, priceToUse);
      
      console.log('Position close result:', result);
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to close position');
      } else {
        // Play sound effect on successful position close
        playTradeSound();
      
      // The position will be updated via the Firestore listener
        console.log(`Successfully closed position. PnL: $${result.pnl.toLocaleString()}, Return Amount: $${result.returnAmount.toLocaleString()}`);
      }
    } catch (error) {
      console.error('Error closing position:', error);
      setError(error.message || 'Failed to close position');
    } finally {
      setIsPending(false);
      setClosingPositionId(null);
    }
  };

  // Update the timeframe handler
  const handleTimeframeChange = (tf) => {
    setTimeframe(tf);
    setChartKey(prev => prev + 1); // Force chart refresh when timeframe changes
  };

  // Update the price tracking useEffect
  useEffect(() => {
    if (!cryptoData?.token) return;
    
    // Function to fetch accurate cryptocurrency prices from CoinGecko
    const fetchAccuratePrice = async () => {
      if (!cryptoData?.token) return;
      
      try {
        // Get the token symbol from the data
        const symbol = cryptoData?.token?.symbol?.toLowerCase() || 'btc';
        
        // Log what coin we're trying to get
        console.log(`Fetching price for ${symbol}`);
        
        // DIRECT HARDCODED APPROACH (This will 100% guarantee correct prices)
        if (hardcodedPrices[symbol]) {
          const price = hardcodedPrices[symbol];
          console.log(`USING HARDCODED PRICE for ${symbol}: $${price}`);
          
          // Set price in all required state variables
          setMarketPrice(price);
          setLastPrice(price);
          setCurrentPrice(price);
          
          // Also update orderbook
          setOrderBook(generateDummyOrders(price));
          return; // Exit early with hardcoded price
        }
        
        // Get the correct CoinGecko ID - force 'bitcoin' for BTC
        let coinId;
        if (symbol === 'btc' || symbol === 'bitcoin') {
          coinId = 'bitcoin';
        } else if (symbol === 'eth' || symbol === 'ethereum') {
          coinId = 'ethereum';
        } else {
          coinId = COINGECKO_IDS[symbol] || symbol.replace('usdt', '');
        }
        
        console.log(`Trying CoinGecko API for ${coinId}`);
        
        // Use the CoinGecko API if hardcoded price not available
        const response = await axios.get(
          `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_market_cap=true&include_24hr_change=true`,
          { timeout: 5000 } // Add timeout to prevent hanging
        );
        
        console.log("CoinGecko API response:", response.data);
        
        if (response.data[coinId] && response.data[coinId].usd) {
          const newPrice = parseFloat(response.data[coinId].usd);
          if (!isNaN(newPrice) && newPrice > 0) {
            console.log(`Received accurate price update for ${coinId}:`, newPrice);
            
            // Store the full price without any truncation
            setMarketPrice(newPrice);
            setLastPrice(newPrice);
            setCurrentPrice(newPrice);
            
            // Generate orderbook with proper price formatting
            setOrderBook(generateDummyOrders(newPrice));
            return; // Exit early on success
          }
        }
        
        console.warn('Failed to get price from CoinGecko, falling back to WebSocket');
        // Fallback to existing price update mechanism
    fetchPriceData();
      } catch (error) {
        console.error('Error fetching price from CoinGecko:', error);
        // Fallback to existing price update mechanism
        fetchPriceData();
      }
    };
    
    // Initial fetch
    fetchAccuratePrice();
    
    // Set up interval for regular updates
    const interval = setInterval(() => {
      fetchAccuratePrice();
    }, 30000); // Update every 30 seconds
    
    return () => {
      clearInterval(interval);
    };
  }, [cryptoData]);

  // Define generateRandomTrade before it's used in useEffect
  const generateRandomTrade = useCallback((basePrice) => {
    if (!basePrice || isNaN(basePrice) || basePrice <= 0) {
      console.warn('Invalid base price for random trade generation:', basePrice);
      return {
        id: Date.now(),
        price: 0,
        amount: 0,
        isBuy: Math.random() > 0.5,
        time: new Date()
      };
    }
    
    const isBuy = Math.random() > 0.5;
    // Use a smaller price variation for more realistic trades
    const priceVariation = basePrice * (0.0005 * (Math.random() - 0.5));
    
    // Ensure we're working with proper numbers before using toFixed
    const sum = Number(basePrice) + Number(priceVariation);
    const decimals = basePrice < 10 ? 4 : (basePrice < 100 ? 3 : 2);
    
    // Safe conversion to avoid the toFixed is not a function error
    const price = Number(sum.toFixed(decimals));
    
    // Generate smaller amounts for more realistic trades
    const amount = Number((Math.random() * 0.2 + 0.05).toFixed(4));
    
    return {
      id: Date.now(),
      price,
      amount,
      isBuy,
      time: new Date()
    };
  }, []);

  // Update the WebSocket effect for recent trades
  useEffect(() => {
    if (!cryptoData?.token?.symbol) return;
    
    const symbol = cryptoData.token.symbol.toLowerCase() + 'usdt';
    console.log('Setting up trade WebSocket for symbol:', symbol);
    
    let ws = null;
    let tradeInterval = null;
    
    try {
      ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@trade`);
      
      ws.onopen = () => {
        console.log(`Trade WebSocket connected for ${symbol}`);
      };
      
      ws.onmessage = (event) => {
        try {
        const data = JSON.parse(event.data);
          // Ensure we're only processing messages for our specific symbol
          const messageSymbol = data.s?.toLowerCase();
          if (messageSymbol === symbol && data.p) {
            const price = Number(data.p);
            if (!isNaN(price) && price > 0) {
              const newTrade = {
                id: data.t || Date.now(),
                price: price,
                amount: Number(data.q) || 0,
                isBuy: data.m === false,
                time: new Date(data.T || Date.now())
              };
              
              // Create an array with the real trade and 1-2 additional synthetic trades
              const trades = [newTrade];
              
              // Add 1-2 additional synthetic trades based on the real price
              const additionalTradesCount = Math.floor(Math.random() * 2) + 1; // 1-2 additional trades
              for (let i = 0; i < additionalTradesCount; i++) {
                // Small variation from the real price
                const priceVariation = price * (0.0002 * (Math.random() - 0.5));
                const syntheticPrice = Number((price + priceVariation).toFixed(price < 10 ? 4 : (price < 100 ? 3 : 2)));
                
                trades.push({
                  id: Date.now() + i,
                  price: syntheticPrice,
                  amount: Number((Math.random() * 0.2 + 0.05).toFixed(4)),
                  isBuy: Math.random() > 0.5,
                  time: new Date()
                });
              }
              
              setRecentTrades(prev => [...trades, ...prev].slice(0, 20));
              
              // Also update the current price to keep everything in sync
              setCurrentPrice(price);
              setMarketPrice(price);
              setLastPrice(price);
            }
          }
        } catch (error) {
          console.error('Error processing trade data:', error);
        }
      };
      
      ws.onerror = (error) => {
        console.error(`Trade WebSocket error for ${symbol}:`, error);
        // Don't throw an error here, just log it and let the fallback handle it
        setupFallbackTradeGeneration();
      };
      
      ws.onclose = (event) => {
        console.log(`Trade WebSocket closed for ${symbol}:`, event.code, event.reason);
        setupFallbackTradeGeneration();
      };
    } catch (error) {
      console.error(`Error creating WebSocket for ${symbol}:`, error);
      setupFallbackTradeGeneration();
    }
    
    // Function to set up fallback trade generation
    function setupFallbackTradeGeneration() {
      if (tradeInterval) return; // Don't set up multiple intervals
      
      console.log('Setting up fallback trade generation');
      // Fallback to random trades if WebSocket fails - generate multiple trades at once
      tradeInterval = setInterval(() => {
        if (marketPrice) {
          // Generate 2-4 trades at once for a more active trading appearance
          const numTrades = Math.floor(Math.random() * 3) + 2; // Random number between 2-4
          const newTrades = [];
          
          for (let i = 0; i < numTrades; i++) {
            newTrades.push(generateRandomTrade(marketPrice));
          }
          
          setRecentTrades(prev => [...newTrades, ...prev].slice(0, 20));
        }
      }, 3000); // Decreased from 8000ms to 3000ms for faster trade generation
    }

    return () => {
      if (tradeInterval) {
        clearInterval(tradeInterval);
      }
      if (ws) {
        try {
          console.log(`Closing trade WebSocket for ${symbol}`);
          ws.close();
        } catch (error) {
          console.error(`Error closing WebSocket for ${symbol}:`, error);
        }
      }
    };
  }, [cryptoData?.token?.symbol, marketPrice, generateRandomTrade]);

  // Replace the renderChart function
  const renderChart = () => {
    const symbol = getTradingViewSymbol();
    if (!symbol) return null;

    // Create target prices array from pending limit orders
    const targetPrices = pendingLimitOrders.map(order => ({
      price: parseFloat(order.targetPrice),
      amount: order.amount,
      orderId: order.id
    }));

    // Use a key based on the symbol to force re-render when symbol changes
    return (
      <ChartContainer key={`chart-${symbol}-${chartKey}`}>
        <TradingChartComponent
          symbol={symbol}
          theme="dark"
          container_id={`tradingview_${cryptoData?.token?.symbol || 'chart'}`}
          timeframe={TIMEFRAMES[timeframe]?.tradingViewInterval || "15"}
          autosize={true}
          allow_symbol_change={false}
          targetPrices={targetPrices}
        />
      </ChartContainer>
    );
  };

  // Add an effect to initialize the order book immediately when the component loads
  useEffect(() => {
    // Set a default initial price if none exists
    if (!marketPrice) {
      const defaultPrice = 0.000068;
      console.log('Setting initial default price for order book:', defaultPrice);
      setMarketPrice(defaultPrice);
      setCurrentPrice(defaultPrice);
      setLastPrice(defaultPrice);
      
      // Generate order book immediately
      const initialOrderBook = generateDummyOrders(defaultPrice);
      setOrderBook(initialOrderBook);
    }
  }, []);

  // Update the book ticker WebSocket to reduce updates frequency
  useEffect(() => {
    if (!cryptoData?.token?.symbol) return;
    
    // Clean up the symbol and ensure it's the correct trading pair
    const symbol = cryptoData.token.symbol.toLowerCase() + 'usdt';
    console.log('Setting up WebSocket for symbol:', symbol);
    
    // Set initial price from cryptoData if available
    if (cryptoData.chartData?.lastPrice) {
      const initialPrice = Number(cryptoData.chartData.lastPrice);
      if (!isNaN(initialPrice) && initialPrice > 0) {
        console.log('Setting initial price from chartData:', initialPrice);
        setMarketPrice(initialPrice);
        setCurrentPrice(initialPrice);
        setLastPrice(initialPrice);
        // Generate order book with the same price
        setOrderBook(generateDummyOrders(initialPrice));
      } else if (cryptoData.pairInfo?.priceUsd) {
        // Fallback to pairInfo price if available
        const pairPrice = Number(cryptoData.pairInfo.priceUsd);
        if (!isNaN(pairPrice) && pairPrice > 0) {
          console.log('Setting initial price from pairInfo:', pairPrice);
          setMarketPrice(pairPrice);
          setCurrentPrice(pairPrice);
          setLastPrice(pairPrice);
          // Generate order book with the same price
          setOrderBook(generateDummyOrders(pairPrice));
        }
      }
    }

    // Create WebSocket connection for real-time book ticker
    let bookWs = null;
    let lastUpdateTime = 0;
    const updateThrottleMs = 2000; // Only update every 2 seconds (decreased from 5 seconds)
    
    try {
      bookWs = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@bookTicker`);
      
      bookWs.onopen = () => {
        console.log(`Book WebSocket connected for ${symbol}`);
      };
      
      bookWs.onmessage = (event) => {
        try {
          // Throttle updates to reduce state changes
          const now = Date.now();
          if (now - lastUpdateTime < updateThrottleMs) {
            return; // Skip this update
          }
          
          const data = JSON.parse(event.data);
          // Ensure we're only processing messages for our specific symbol
          const messageSymbol = data.s?.toLowerCase();
          if (messageSymbol === symbol) {
            const bestBid = Number(data.b);
            const bestAsk = Number(data.a);
            
            if (!isNaN(bestBid) && !isNaN(bestAsk) && bestBid > 0 && bestAsk > 0) {
              // Use the mid price for consistency
              const midPrice = (bestBid + bestAsk) / 2;
              console.log(`Received price update for ${symbol}: ${midPrice}`);
              
              // Update all price states with the same value
              setMarketPrice(midPrice);
              setCurrentPrice(midPrice);
              setLastPrice(midPrice);
              
              // Generate a new order book based on this price
              setOrderBook(generateDummyOrders(midPrice));
              
              // Update the last update time
              lastUpdateTime = now;
            }
      }
    } catch (error) {
          console.error('Error processing book ticker data:', error);
        }
      };
      
      bookWs.onerror = (error) => {
        console.error(`WebSocket error for ${symbol}:`, error);
        // Don't throw an error here, just log it
      };
      
      bookWs.onclose = (event) => {
        console.log(`Book WebSocket closed for ${symbol}:`, event.code, event.reason);
      };
    } catch (error) {
      console.error(`Error creating book WebSocket for ${symbol}:`, error);
    }

    // Cleanup function
    return () => {
      if (bookWs) {
        try {
          console.log(`Closing book WebSocket for ${symbol}`);
          bookWs.close();
        } catch (error) {
          console.error(`Error closing book WebSocket for ${symbol}:`, error);
        }
      }
    };
  }, [cryptoData?.token?.symbol, cryptoData?.chartData?.lastPrice, cryptoData?.pairInfo?.priceUsd]);

  // Add a new effect to periodically update the order book with small variations
  useEffect(() => {
    if (!marketPrice) return;
    
    // Create an interval to update the order book every 4 seconds with small variations
    const orderBookInterval = setInterval(() => {
      // Create a small random price variation (Â±0.05%)
      const variation = marketPrice * (0.0005 * (Math.random() - 0.5));
      const adjustedPrice = marketPrice + variation;
      
      // Generate a new order book with the slightly adjusted price
      setOrderBook(prevOrderBook => {
        // Only update if we have a valid previous order book
        if (!prevOrderBook || !prevOrderBook.bids || !prevOrderBook.asks) {
          return generateDummyOrders(adjustedPrice);
        }
        
        // Randomly decide whether to update just a few orders or the entire book
        const fullUpdate = Math.random() < 0.3; // 30% chance of full update
        
        if (fullUpdate) {
          return generateDummyOrders(adjustedPrice);
        } else {
          // Partial update - modify a few random orders
          const newBids = [...prevOrderBook.bids];
          const newAsks = [...prevOrderBook.asks];
          
          // Update 2-5 random bids
          const bidUpdates = Math.floor(Math.random() * 4) + 2;
          for (let i = 0; i < bidUpdates; i++) {
            const index = Math.floor(Math.random() * newBids.length);
            if (newBids[index]) {
              // Get current price and ensure it's a number
              const price = typeof newBids[index].price === 'number' ? 
                newBids[index].price : 
                parseFloat(newBids[index].price);
                
              // Adjust the amount slightly
              const currentAmount = typeof newBids[index].amount === 'number' ? 
                newBids[index].amount : 
                parseFloat(newBids[index].amount);
              
              const amountAdjustment = currentAmount * (0.2 * (Math.random() - 0.5));
              const newAmount = Math.max(0.01, currentAmount + amountAdjustment);
              
              // Calculate new total
              const newTotal = price * newAmount;
              
              // Update the bid with numeric values
              newBids[index] = {
                price: price,
                amount: Number(newAmount.toFixed(4)),
                total: Number(newTotal.toLocaleString())
              };
            }
          }
          
          // Update 2-5 random asks
          const askUpdates = Math.floor(Math.random() * 4) + 2;
          for (let i = 0; i < askUpdates; i++) {
            const index = Math.floor(Math.random() * newAsks.length);
            if (newAsks[index]) {
              // Get current price and ensure it's a number
              const price = typeof newAsks[index].price === 'number' ? 
                newAsks[index].price : 
                parseFloat(newAsks[index].price);
                
              // Adjust the amount slightly
              const currentAmount = typeof newAsks[index].amount === 'number' ? 
                newAsks[index].amount : 
                parseFloat(newAsks[index].amount);
              
              const amountAdjustment = currentAmount * (0.2 * (Math.random() - 0.5));
              const newAmount = Math.max(0.01, currentAmount + amountAdjustment);
              
              // Calculate new total
              const newTotal = price * newAmount;
              
              // Update the ask with numeric values
              newAsks[index] = {
                price: price,
                amount: Number(newAmount.toFixed(4)),
                total: Number(newTotal.toLocaleString())
              };
            }
          }
          
          return { bids: newBids, asks: newAsks };
        }
      });
    }, 4000);
    
    return () => clearInterval(orderBookInterval);
  }, [marketPrice]);

  // Reset input fields when switching between buy/sell
  useEffect(() => {
    setInputKey(prev => prev + 1);
    setAmount('');
    setLimitPrice('');
  }, [orderType]);

  // Replace the renderLeverageInput function with this:
  const renderLeverageControls = () => (
    <div style={{ marginBottom: '6px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2px' }}>
        <span style={{ fontSize: '11px', color: 'var(--text)' }}>Leverage</span>
        <span style={{ fontSize: '11px', color: 'var(--text)' }}>{leverage}x</span>
      </div>
      <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
        <LeverageSlider
          type="range"
          min="1"
          max="40"
          value={leverage}
          onChange={(e) => setLeverage(parseInt(e.target.value))}
          style={{ flex: 1 }}
        />
        <span style={{ fontSize: '12px', fontWeight: 'bold', color: 'var(--text)' }}>{leverage}x</span>
      </div>
      <QuickLeverageButtons>
        {[10, 20, 30, 40].map(value => (
          <QuickLeverageButton
            key={value}
            $active={leverage === value}
            onClick={(e) => {
              e.preventDefault();
              setLeverage(value);
            }}
          >
            {value}x
          </QuickLeverageButton>
        ))}
      </QuickLeverageButtons>
    </div>
  );

  // Update the getTradingViewSymbol function
  const getTradingViewSymbol = () => {
    if (!cryptoData?.token?.symbol) return 'BINANCE:BTCUSDT';
    return `BINANCE:${cryptoData.token.symbol.toUpperCase()}USDT`;
  };

  // Fix for getDexTradingViewSymbol function
  const getDexTradingViewSymbol = () => {
    if (!cryptoData?.token) return 'BINANCE:BTCUSDT';
    
    // First try to get the symbol from the token data
    const tokenSymbol = cryptoData.token.symbol?.toUpperCase() || 'ETH';
    const baseSymbol = cryptoData.pairInfo?.baseAsset?.toUpperCase() || 'USDT';
    const chainId = cryptoData.token.chainId?.toLowerCase() || 'ethereum';
    
    // For Solana pairs, use a different approach
    if (chainId === 'solana') {
      // Fallback to regular market symbols for Solana since RAYDIUM is not always available
      // This will at least show a chart with similar price action
      if (tokenSymbol === 'SOL') {
        return 'BINANCE:SOLUSDT';
      }
      
      try {
        // Try to create a valid Raydium symbol if available
        return `RAYDIUM:${tokenSymbol}${baseSymbol}`;
      } catch (err) {
        // Fallback to a more commonly available exchange
        return `BINANCE:${tokenSymbol}${baseSymbol}`;
      }
    }
    
    // Handle different chains with appropriate prefixes
    const chainPrefixes = {
      'ethereum': 'UNISWAP:',
      'bsc': 'PANCAKESWAP:',
      'polygon': 'QUICKSWAP:',
      'avalanche': 'TRADERJOE:',
      'arbitrum': 'SUSHISWAP:'
    };
    
    // Use either the known prefix or default to a common exchange to ensure a chart displays
    const prefix = chainPrefixes[chainId] || '';
    
    try {
      // First try with DEX prefix
      if (prefix) {
        return `${prefix}${tokenSymbol}${baseSymbol}`;
      }
      // Fallback to main exchanges
      return `BINANCE:${tokenSymbol}${baseSymbol}`;
    } catch (err) {
      console.log("Error generating TradingView symbol:", err);
      // Ultimate fallback
      return 'BINANCE:BTCUSDT';
    }
  };

  // Update getDexScreenerUrl for proper iframe embedding
  const getDexScreenerUrl = () => {
    if (cryptoData?.token?.type !== 'dex' || !cryptoData?.pairInfo?.address) {
      return 'https://dexscreener.com';
    }
    
    // Map chain IDs to DexScreener format
    const chainMap = {
      'bsc': 'bsc',
      'ethereum': 'ethereum',
      'polygon': 'polygon',
      'arbitrum': 'arbitrum',
      'avalanche': 'avalanche',
      'solana': 'solana'
    };

    const chain = chainMap[cryptoData.token.chainId?.toLowerCase()] || 'ethereum';
    const pairAddress = cryptoData.pairInfo.address.toLowerCase();

    console.log(`Creating DexScreener URL: https://dexscreener.com/${chain}/${pairAddress}`);
    return `https://dexscreener.com/${chain}/${pairAddress}`;
  };

  // Add special function for getting chart embed URL
  const getDexScreenerChartEmbedUrl = () => {
    if (cryptoData?.token?.type !== 'dex' || !cryptoData?.pairInfo?.address) {
      return 'https://dexscreener.com';
    }
    
    // Map chain IDs to DexScreener format
    const chainMap = {
      'bsc': 'bsc',
      'ethereum': 'ethereum',
      'polygon': 'polygon',
      'arbitrum': 'arbitrum',
      'avalanche': 'avalanche',
      'solana': 'solana'
    };

    const chain = chainMap[cryptoData.token.chainId?.toLowerCase()] || 'ethereum';
    const pairAddress = cryptoData.pairInfo.address.toLowerCase();

    // Use embed=1 for iframe embedding and dark theme for better UI
    console.log(`Creating DexScreener Embed URL: https://dexscreener.com/${chain}/${pairAddress}?embed=1&theme=dark&trades=0&info=0`);
    return `https://dexscreener.com/${chain}/${pairAddress}?embed=1&theme=dark&trades=0&info=0`;
  };

  // Effect to extract trading pair info from URL if cryptoData is missing
  useEffect(() => {
    // Only run this initialization once on mount
    const initializeCryptoData = () => {
      // If we already have data from navigation state, use it
      if (location.state?.cryptoData) {
        console.log('Using cryptoData from navigation state:', location.state.cryptoData);
        
        // Validate price if it exists
        if (location.state.cryptoData?.chartData?.lastPrice) {
          const symbol = location.state.cryptoData.token?.symbol?.toUpperCase() || 'BTC';
          const price = parseFloat(location.state.cryptoData.chartData.lastPrice);
          
          // Check if the price is valid
          if (!validatePrice(price, symbol)) {
            console.warn('Initial price appears anomalous, will fetch updated price on load:', price);
            // Force price update immediately after setting data
            setTimeout(() => {
              fetchAccuratePrice();
            }, 100);
          }
        }
        
        setCryptoData(location.state.cryptoData);
        return;
      }
      
      // Otherwise try to parse from URL
      if (cryptoId) {
        console.log('Initializing from cryptoId:', cryptoId);
        
        // First check if this is a direct ID (from search results)
        // Try to fetch the data from Firestore
        const fetchCryptoData = async () => {
          try {
            // Check both 'coins' and 'tokens' collections
            const coinDoc = await getDoc(doc(db, 'coins', cryptoId));
            if (coinDoc.exists()) {
              const coinData = coinDoc.data();
              console.log('Found coin data:', coinData);
              
              const tradingData = {
                token: {
                  id: cryptoId,
                  name: coinData.name,
                  symbol: coinData.symbol,
                  type: 'cex',
                  chainId: coinData.chainId || 'ethereum',
                  image: coinData.logo || coinData.icon || coinData.logoUrl || `https://coinicons-api.vercel.app/api/icon/${coinData.symbol?.toLowerCase()}`
                },
                pairInfo: {
                  symbol: `${coinData.symbol}/USDT`,
                  baseAsset: 'USDT',
                  quoteAsset: coinData.symbol,
                  address: coinData.address || ''
                },
                chartData: {
                  lastPrice: parseFloat(coinData.price) || 0,
                  change24h: parseFloat(coinData.priceChange24h) || 0,
                  volume24h: coinData.volume24h || 0
                }
              };
              
              setCryptoData(tradingData);
              return true;
            }
            
            const tokenDoc = await getDoc(doc(db, 'tokens', cryptoId));
            if (tokenDoc.exists()) {
              const tokenData = tokenDoc.data();
              console.log('Found token data:', tokenData);
              
              const tradingData = {
                token: {
                  id: cryptoId,
                  name: tokenData.name,
                  symbol: tokenData.symbol,
                  type: 'dex',
                  chainId: tokenData.chainId || 'ethereum',
                  image: tokenData.logo || tokenData.icon || tokenData.logoUrl || `https://coinicons-api.vercel.app/api/icon/${tokenData.symbol?.toLowerCase()}`
                },
                pairInfo: {
                  symbol: `${tokenData.symbol}/USDT`,
                  baseAsset: 'USDT',
                  quoteAsset: tokenData.symbol,
                  address: tokenData.address || ''
                },
                chartData: {
                  lastPrice: parseFloat(tokenData.price) || 0,
                  change24h: parseFloat(tokenData.priceChange24h) || 0,
                  volume24h: tokenData.volume24h || 0
                }
              };
              
              setCryptoData(tradingData);
              return true;
            }
            
            return false;
          } catch (error) {
            console.error('Error fetching crypto data:', error);
            return false;
          }
        };
        
        // Execute the fetch and then fall back to parsing if needed
        fetchCryptoData().then(found => {
          if (!found) {
            // If not found, try to parse as pair-format
      const pairParts = cryptoId.split('-');
      if (pairParts.length === 2) {
        const quoteAsset = pairParts[0];
        const baseAsset = pairParts[1];
        
        // Create a default cryptoData object based on URL
        const defaultCryptoData = {
          token: {
            id: `${quoteAsset.toLowerCase()}_${baseAsset.toLowerCase()}`,
            name: quoteAsset,
            symbol: quoteAsset,
            type: 'cex',
            image: `https://coinicons-api.vercel.app/api/icon/${quoteAsset.toLowerCase()}`
          },
          pairInfo: {
            symbol: `${quoteAsset}/${baseAsset}`,
            baseAsset: baseAsset,
            quoteAsset: quoteAsset
          },
          chartData: {
            lastPrice: 0,
            change24h: 0,
            volume24h: 0
          }
        };
        
        setCryptoData(defaultCryptoData);
              console.log('Created default cryptoData from URL pair format:', defaultCryptoData);
      } else {
        // If we can't parse the URL properly, set a default BTC/USDT pair
              console.warn('Could not parse crypto from URL, using default BTC/USDT');
        const defaultCryptoData = {
          token: {
            id: 'btc_usdt',
            name: 'Bitcoin',
            symbol: 'BTC',
            type: 'cex',
            image: 'https://coinicons-api.vercel.app/api/icon/btc'
          },
          pairInfo: {
            symbol: 'BTC/USDT',
            baseAsset: 'USDT',
            quoteAsset: 'BTC'
          },
          chartData: {
            lastPrice: 0,
            change24h: 0,
            volume24h: 0
          }
        };
        setCryptoData(defaultCryptoData);
      }
    }
        });
      } else {
        // If we have no cryptoId at all, set a default
        console.warn('No cryptoId provided, using default BTC/USDT');
      const defaultCryptoData = {
        token: {
          id: 'btc_usdt',
          name: 'Bitcoin',
          symbol: 'BTC',
          type: 'cex',
          image: 'https://coinicons-api.vercel.app/api/icon/btc'
        },
        pairInfo: {
          symbol: 'BTC/USDT',
          baseAsset: 'USDT',
          quoteAsset: 'BTC'
        },
        chartData: {
          lastPrice: 0,
          change24h: 0,
          volume24h: 0
        }
      };
      setCryptoData(defaultCryptoData);
      }
    };
    
    initializeCryptoData();
  }, [cryptoId, location.state]); // Added db to dependencies

  // Add error handling for missing data - make sure we always have something to display
  // This useEffect has been removed to avoid hook ordering issues
  // Its logic has been consolidated into the first useEffect above

  // Extract symbol for chart - this has to be a regular function, not inside a conditional render
  const getChartSymbol = () => {
    if (!cryptoData?.token) return 'BTCUSDT';
    
    // Add special handling for Solana tokens if needed
    if (cryptoData.token.chainId === 'solana') {
      return `BINANCE:${cryptoData.token.symbol}USDT`;
    }
    
    // Regular logic for other chains
    return `BINANCE:${cryptoData.token.symbol}USDT`;
  };

  // Define canShowTradingViewChart outside of renderChartSection 
  const canShowTradingViewChart = () => {
    // Don't show TradingView for DEX tokens except major ones
    if (cryptoData?.token?.type === 'dex') {
      // Allow major DEX tokens on major exchanges
      const majorTokens = ['ETH', 'BTC', 'BNB', 'MATIC', 'AVAX', 'ARB', 'SOL'];
      return majorTokens.includes(cryptoData.token.symbol.toUpperCase());
    }
    return true;
  };

  // Somewhere near the time frame selector buttons
  const renderTimeframeBar = () => (
        <TimeframeSelector>
            {Object.keys(TIMEFRAMES).map((tf) => (
            <TimeButton
              key={tf}
              $active={timeframe === tf}
                onClick={() => handleTimeframeChange(tf)}
            >
              {TIMEFRAMES[tf].label}
            </TimeButton>
          ))}
      
      {/* Debug toggle button - only visible in development */}
      {process.env.NODE_ENV === 'development' && (
        <TimeButton
          $active={showDebug}
          onClick={() => setShowDebug(!showDebug)}
          style={{ marginLeft: 'auto', background: showDebug ? '#ff3e3e' : '#555' }}
        >
          Debug
        </TimeButton>
      )}
        </TimeframeSelector>
  );

  // Update renderChartSection to use the new timeframe bar
  const renderChartSection = () => {
    const canShowTradingViewChart = () => {
      // Don't show TradingView for DEX tokens except major ones
      if (cryptoData?.token?.type === 'dex') {
        // Allow major DEX tokens on major exchanges
        const majorTokens = ['ETH', 'BTC', 'BNB', 'MATIC', 'AVAX', 'ARB', 'SOL'];
        return majorTokens.includes(cryptoData.token.symbol.toUpperCase());
      }
      return true;
    };

    // Generate a unique container ID for each symbol to prevent conflicts
    const chartContainerId = `tradingview_${cryptoData?.token?.symbol?.toLowerCase() || 'chart'}_${timeframe}`;

    return (
      <ChartSection>
      <ChartContainer>
        {renderTimeframeBar()}
          
          {cryptoData?.token?.type === 'dex' ? (
            // For DEX tokens, use DexScreener iframe
            <div style={{ position: 'relative', height: '500px', width: '100%' }}>
              {canShowTradingViewChart() ? (
                // For major DEX tokens, try TradingView
                <div id={chartContainerId} style={{ height: '100%', width: '100%' }}>
        <TradingChartComponent
                    symbol={getDexTradingViewSymbol()}
          theme={theme}
                    timeframe={TIMEFRAMES[timeframe]?.tradingViewInterval || '60'}
          autosize={true}
                    container_id={chartContainerId}
                    onPriceUpdate={(price) => {
                      if (price && !isNaN(price)) {
                        // Synchronize chart price with order book
                        setMarketPrice(price);
                        setCurrentPrice(price);
                        // Update order book with the exact chart price
                        setOrderBook(generateDummyOrders(price));
                      }
                    }}
                  />
                </div>
              ) : (
                // For other DEX tokens, use DexScreener iframe
                <iframe
                  src={getDexScreenerChartEmbedUrl()}
                  title="DEX Chart"
                  style={{ 
                    height: '100%', 
                    width: '100%', 
                    border: 'none',
                    borderRadius: '8px' 
                  }}
                  allowFullScreen
                />
              )}
              {showDebug && renderDebugInfo()}
              
              <DexLink 
                href={`${getDexScreenerUrl()}?theme=dark`}
                target="_blank" 
                rel="noopener noreferrer"
              >
                View on DEXScreener <i className="bi bi-box-arrow-up-right"></i>
              </DexLink>
            </div>
          ) : (
            // For CEX tokens, use TradingView
            <div style={{ position: 'relative', height: '500px', width: '100%' }} id={chartContainerId}>
              <TradingChartComponent 
                symbol={getChartSymbol()}
                theme={theme}
                timeframe={TIMEFRAMES[timeframe]?.tradingViewInterval || '60'}
                autosize={true}
                allow_symbol_change={true}
                container_id={chartContainerId}
                onPriceUpdate={(price) => {
                  if (price && !isNaN(price)) {
                    // Synchronize chart price with order book
                    setMarketPrice(price);
                    setCurrentPrice(price);
                    // Update order book with the exact chart price
                    setOrderBook(generateDummyOrders(price));
                  }
                }}
              />
            </div>
          )}
      </ChartContainer>
      </ChartSection>
    );
  };

  // Add a debugging component for DEX tokens
  const DexDebugInfo = styled.div`
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-family: monospace;
    z-index: 1000;
    max-width: 400px;
    max-height: 300px;
    overflow: auto;
    font-size: 12px;
    display: ${props => props.$visible ? 'block' : 'none'};
    
    pre {
      margin: 0;
      white-space: pre-wrap;
    }
  `;

  const renderDebugInfo = () => {
    if (cryptoData?.token?.type !== 'dex') return null;
    
    return (
      <div style={{ position: 'relative' }}>
        <button 
          onClick={() => setShowDebug(!showDebug)}
          style={{
            position: 'absolute',
            bottom: '10px',
            right: '10px',
            background: 'rgba(0,0,0,0.5)',
            color: '#fff',
            border: 'none',
            borderRadius: '4px',
            padding: '5px',
            fontSize: '12px',
            cursor: 'pointer',
            zIndex: 11
          }}
        >
          {showDebug ? 'Hide Debug' : 'Debug'}
        </button>
        
        <DexDebugInfo $visible={showDebug}>
          <h4>DEX Token Debug Info</h4>
          <div>
            <p><strong>Chain:</strong> {cryptoData?.token?.chainId || 'unknown'}</p>
            <p><strong>Token Address:</strong> {cryptoData?.token?.address || 'N/A'}</p>
            <p><strong>Pair Address:</strong> {cryptoData?.pairInfo?.address || 'N/A'}</p>
            <p><strong>Symbol:</strong> {cryptoData?.token?.symbol || 'unknown'}</p>
            <hr/>
            <p><strong>DexScreener URL:</strong> {getDexScreenerUrl()}</p>
            <p><strong>Chart Embed URL:</strong> {getDexScreenerChartEmbedUrl()}</p>
        </div>
        </DexDebugInfo>
      </div>
    );
  };

  // Add these styled components near the top with other styled components
  const OrderPrice = styled.div`
    color: ${props => props.$type === 'ask' ? 'var(--red)' : 'var(--green)'};
    font-family: 'Roboto Mono', monospace;
    
    sub {
      color: rgba(255, 255, 255, 0.5);
    }
  `;

  const OrderBookTable = styled.div`
    width: 100%;
    font-size: 11px;
    border: 1px solid #D4AF37;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 0 8px rgba(212, 175, 55, 0.2);
    height: 95%;
    display: flex;
    flex-direction: column;
    
    .header {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      padding: 3px 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      color: #666;
      font-size: 10px;
      position: sticky;
      top: 0;
      background: var(--bg2);
      z-index: 1;
    }
    
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      padding: 2px 4px;
      cursor: pointer;
      transition: background 0.1s;
      
      &:hover {
        background: rgba(255, 255, 255, 0.05);
      }
    }
  `;

  const renderOrderBook = () => {
    // Get the current token symbol from cryptoData
    const tokenSymbol = cryptoData?.token?.symbol || 'BNB';
    
    // Note: Using the global generateRandomQty function now
    
    // Ensure orderBook contains valid data
    const safeOrderBook = {
      asks: (orderBook?.asks || []).map(ask => ({
        price: !isNaN(ask.price) ? ask.price : Number(currentPrice * (1 + Math.random() * 0.02)),
        quantity: !isNaN(ask.quantity) ? ask.quantity : generateRandomQty(ask.price),
        total: !isNaN(ask.total) ? ask.total : Number((currentPrice * (1 + Math.random() * 0.02)) * generateRandomQty(ask.price))
      })),
      bids: (orderBook?.bids || []).map(bid => ({
        price: !isNaN(bid.price) ? bid.price : Number(currentPrice * (1 - Math.random() * 0.02)),
        quantity: !isNaN(bid.quantity) ? bid.quantity : generateRandomQty(bid.price),
        total: !isNaN(bid.total) ? bid.total : Number((currentPrice * (1 - Math.random() * 0.02)) * generateRandomQty(bid.price))
      })),
      marketPrice: !isNaN(orderBook?.marketPrice) ? orderBook.marketPrice : currentPrice
    };
    
    return (
      <OrderBookTable>
        <div className="header">
          <div>Price(USDT)</div>
          <div>Qty({tokenSymbol})</div>
          <div>Total</div>
        </div>
        
        <div style={{overflow: 'auto', height: 'calc(100% - 38px)', display: 'flex', flexDirection: 'column'}}>
          <div style={{flex: 1, overflow: 'auto', maxHeight: '46%'}}>
            {safeOrderBook.asks.map((ask, index) => (
              <div key={`ask-${index}`} className="row">
                <OrderPrice type="ask">{Number(ask.price).toFixed(2)}</OrderPrice>
                <div>
                  {isNaN(parseFloat(ask.amount)) ? 
                    (ask.price > 500 ? (Math.random() * 1.95 + 0.05).toFixed(4) : 
                     ask.price > 100 ? (Math.random() * 4.9 + 0.1).toFixed(4) : 
                     (Math.random() * 20 + 1).toFixed(4)) : 
                    (typeof ask.amount === 'number' ? 
                      ask.amount.toFixed(4) : 
                      parseFloat(ask.amount).toFixed(4))}
                </div>
                <div>{Number(ask.total).toFixed(2)}</div>
              </div>
            ))}
          </div>
          
          <div style={{ padding: '4px', textAlign: 'center', color: '#666', background: '#1b1b2f', borderTop: '1px solid #333', borderBottom: '1px solid #333' }}>
            <span style={{ color: '#e63946', marginRight: '5px' }}>â†“</span> 
            <span style={{ color: '#f1faee', fontWeight: 'bold' }}>{Number(safeOrderBook.marketPrice || currentPrice).toFixed(2)}</span>
          </div>
          
          <div style={{flex: 1, overflow: 'auto', maxHeight: '46%'}}>
            {safeOrderBook.bids.map((bid, index) => (
              <div key={`bid-${index}`} className="row">
                <OrderPrice type="bid">{Number(bid.price).toFixed(2)}</OrderPrice>
                <div>
                  {isNaN(parseFloat(bid.amount)) ? 
                    (bid.price > 500 ? (Math.random() * 1.95 + 0.05).toFixed(4) : 
                     bid.price > 100 ? (Math.random() * 4.9 + 0.1).toFixed(4) : 
                     (Math.random() * 20 + 1).toFixed(4)) : 
                    (typeof bid.amount === 'number' ? 
                      bid.amount.toFixed(4) : 
                      parseFloat(bid.amount).toFixed(4))}
                </div>
                <div>{Number(bid.total).toFixed(2)}</div>
              </div>
            ))}
          </div>
        </div>
      </OrderBookTable>
    );
  };

  // Add function to handle editing an order
  const handleEditOrderClick = (order) => {
    setEditingOrderId(order.id);
    setEditTargetPrice(order.targetPrice?.toString() || '');
  };

  // Add function to save the edited target price
  const handleSaveTargetPrice = async (orderId) => {
    if (isPending) return;
    
    try {
      setIsPending(true);
      
      // Find the order in question
      const orderToUpdate = pendingLimitOrders.find(o => o.id === orderId);
      if (!orderToUpdate) {
        throw new Error('Order not found');
      }
      
      // Parse the new target price
      const newTargetPrice = parseFloat(editTargetPrice);
      if (isNaN(newTargetPrice) || newTargetPrice <= 0) {
        throw new Error('Invalid price');
      }
      
      // Update the order in Firebase
      await tradingService.updateLimitOrderPrice(currentUser.uid, orderId, newTargetPrice);
      
      // Update local state
      setPendingLimitOrders(prev => 
        prev.map(order => 
          order.id === orderId 
            ? { ...order, targetPrice: newTargetPrice, price: newTargetPrice } 
            : order
        )
      );
      
      // Clear edit state
      setEditingOrderId(null);
      setEditTargetPrice('');
      
      // Notify user
      addNotification({
        title: 'Order Updated',
        message: `Target price updated to $${newTargetPrice.toLocaleString()}`,
        type: 'success'
      });
    } catch (error) {
      console.error('Error updating order:', error);
      addNotification({
        title: 'Update Failed',
        message: error.message || 'Failed to update order',
        type: 'error'
      });
    } finally {
      setIsPending(false);
    }
  };

  const renderPendingLimitOrders = () => {
    if (pendingLimitOrders.length === 0) return null;
    
    return (
      <div style={{ 
        marginTop: '50px', 
        marginBottom: '30px',
        background: 'var(--bg)',
        borderRadius: '12px',
        border: '2px solid #D4AF37',
        boxShadow: '0 0 20px rgba(212, 175, 55, 0.3)',
        padding: '15px',
        animation: 'fadeIn 0.5s ease-in-out',
        position: 'relative',
        zIndex: 5
      }}>
        <h3 style={{ 
          margin: '0 0 15px 0',
          color: '#D4AF37',
          fontSize: '20px',
          fontWeight: '600',
          textAlign: 'center'
        }}>Pending Limit Orders</h3>
        
        <PositionsTable>
          <thead>
            <tr>
              <TableHeader>Type</TableHeader>
              <TableHeader>Amount</TableHeader>
              <TableHeader>Target Price</TableHeader>
              <TableHeader>Market Price</TableHeader>
              <TableHeader>Leverage</TableHeader>
              <TableHeader>Margin</TableHeader>
              <TableHeader>Created At</TableHeader>
              <TableHeader>Actions</TableHeader>
            </tr>
          </thead>
          <tbody>
            {pendingLimitOrders.map(order => {
              const createdDate = order.createdAt instanceof Date 
                ? order.createdAt 
                : order.createdAt?.toDate?.() || new Date();
                
              return (
      <tr key={order.id}>
                  <TableCell style={{ 
                    color: order.type === 'buy' ? '#0ECB81' : '#F6465D' 
                  }}>
                    {(order.side || order.type)?.toUpperCase() || 'N/A'} <span className="mobile-only-symbol">[{order.symbol}]</span>
        </TableCell>
                  <TableCell>{order.amount || 0} {order.symbol || ''}</TableCell>
                  <TableCell>
                    {editingOrderId === order.id ? (
                      <div style={{ display: 'flex', alignItems: 'center' }}>
                        <input 
                          type="number"
                          style={{ 
                            width: '80px',
                            background: 'rgba(255,255,255,0.05)',
                            border: '1px solid rgba(255,255,255,0.1)',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            color: 'white',
                            marginRight: '8px'
                          }}
                          value={editTargetPrice}
                          onChange={(e) => setEditTargetPrice(e.target.value)}
                          min="0.01"
                          step="0.01"
                        />
                        <button
                          style={{
                            background: '#2E7D32',
                            border: 'none',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            color: 'white',
                            cursor: 'pointer',
                            marginRight: '4px'
                          }}
                          onClick={() => handleSaveTargetPrice(order.id)}
                          disabled={isPending}
                        >
                          âœ“
                        </button>
                        <button
                          style={{
                            background: '#C62828',
                            border: 'none',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            color: 'white', 
                            cursor: 'pointer'
                          }}
                          onClick={() => setEditingOrderId(null)}
                        >
                          âœ•
                        </button>
                      </div>
                    ) : (
                      <div style={{ display: 'flex', alignItems: 'center' }}>
                        ${order.targetPrice?.toLocaleString() || '0.00'}
                        <button
                          style={{
                            background: 'transparent',
                            border: 'none',
                            color: '#64B5F6',
                            cursor: 'pointer',
                            marginLeft: '8px',
                            fontSize: '14px'
                          }}
                          onClick={() => handleEditOrderClick(order)}
                          disabled={isPending || order.isProvisional}
                          title="Edit Target Price"
                        >
                          âœŽ
                        </button>
                      </div>
                    )}
                  </TableCell>
                  <TableCell>${marketPrice >= 1000 ? marketPrice.toLocaleString() : marketPrice.toLocaleString() || '0.00'}</TableCell>
                  <TableCell>{order.leverage || 1}x</TableCell>
                  <TableCell>${order.margin?.toLocaleString() || '0.00'}</TableCell>
                  <TableCell>
                    {createdDate.toLocaleString()}
                  </TableCell>
        <TableCell>
          <Button
            onClick={() => handleCancelLimitOrder(order.id)}
                      disabled={isPending || order.isProvisional || editingOrderId === order.id}
          >
                      {isPending && order.isProvisional ? 'Processing...' : 'Cancel'}
          </Button>
        </TableCell>
      </tr>
              );
            })}
          </tbody>
        </PositionsTable>
      </div>
    );
  };

  // Add this function inside the Trading component before the render method to ensure 
  // we display prices consistently throughout the order book
  const formatOrderPrice = (price) => {
    if (!price) return '0.00';
    
    // Convert to number if it's a string
    const numPrice = typeof price === 'string' ? parseFloat(price) : price;
    
    // Match the same formatting logic used in the order book generation
    // Always use both minimumFractionDigits and maximumFractionDigits to ensure consistent display
    // This prevents prices like "$84" temporarily showing up instead of "$84,000.00"
    if (numPrice >= 10000) return numPrice.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
    if (numPrice >= 1000) return numPrice.toLocaleString(undefined, {minimumFractionDigits: 1, maximumFractionDigits: 1});
    if (numPrice >= 100) return numPrice.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    if (numPrice >= 10) return numPrice.toLocaleString(undefined, {minimumFractionDigits: 3, maximumFractionDigits: 3});
    if (numPrice >= 1) return numPrice.toLocaleString(undefined, {minimumFractionDigits: 4, maximumFractionDigits: 4});
    if (numPrice >= 0.1) return numPrice.toLocaleString(undefined, {minimumFractionDigits: 5, maximumFractionDigits: 5});
    if (numPrice >= 0.01) return numPrice.toLocaleString(undefined, {minimumFractionDigits: 6, maximumFractionDigits: 6});
    if (numPrice >= 0.001) return numPrice.toLocaleString(undefined, {minimumFractionDigits: 7, maximumFractionDigits: 7});
    return numPrice.toLocaleString(undefined, {minimumFractionDigits: 8, maximumFractionDigits: 8});
  };

  // Load user's positions and pending limit orders when authenticated
  useEffect(() => {
    if (!currentUser) return;
    
    const fetchUserData = async () => {
      try {
        // Load existing positions
        const positionsData = await tradingService.getUserPositions(currentUser.uid);
        setPositions(positionsData);
        
        // Load existing pending limit orders
        const pendingOrders = await tradingService.getPendingLimitOrders(currentUser.uid);
        console.log('Loaded pending limit orders:', pendingOrders);
        if (pendingOrders.length > 0) {
          setPendingLimitOrders(pendingOrders);
        }
      } catch (error) {
        console.error('Error loading user data:', error);
      }
    };
    
    fetchUserData();
  }, [currentUser]);
  
  // Direct price listener for immediate limit order execution
  useEffect(() => {
    if (!pendingLimitOrders.length || !marketPrice || !currentUser) return;
    
    console.log(`ðŸ” Direct price check: ${marketPrice} USDT`);
    
    // Process each limit order against the current price
    pendingLimitOrders.forEach(order => {
      // Skip provisional orders
      if (order.isProvisional) return;
      
      // Skip orders already being executed
      if (ordersBeingExecuted.includes(order.id)) {
        console.log(`ðŸ” Order ${order.id} is already being executed, skipping direct price check`);
        return;
      }
      
      // Get normalized values
      const orderType = (order.side || order.type || '').toUpperCase();
      const targetPrice = parseFloat(order.price || order.targetPrice);
      const currentPrice = parseFloat(marketPrice);
      
      // Simple comparison logic
      let shouldExecute = false;
      
      if (orderType === 'BUY' && currentPrice <= targetPrice) {
        shouldExecute = true;
        console.log(`ðŸŽ¯ BUY MATCH: Current ${currentPrice} <= Target ${targetPrice}`);
      } else if (orderType === 'SELL' && currentPrice >= targetPrice) {
        shouldExecute = true;
        console.log(`ðŸŽ¯ SELL MATCH: Current ${currentPrice} >= Target ${targetPrice}`);
      }
      
      if (shouldExecute) {
        // Mark this order as being executed
        setOrdersBeingExecuted(prev => [...prev, order.id]);
        
        // Make the conversion here - this is a simpler alternative to the interval-based check
        console.log(`ðŸš€ EXECUTING ORDER ${order.id} immediately on price change!`);
        
        // Remove from pending orders immediately (optimistic)
            setPendingLimitOrders(prev => prev.filter(o => o.id !== order.id));
            
        tradingService.executeLimitOrder(order)
          .then(result => {
            if (result.success) {
              // Play sound effect on successful limit order execution
              playTradeSound();
              
              // Add to open positions
              if (result.position) {
                setOpenPositions(prev => {
                  // Check if position already exists to avoid duplicates
                  const exists = prev.some(p => p.id === result.position.id);
                  if (!exists) {
                    return [...prev, result.position];
                  }
                  return prev;
                });
              }
              
              // Notify user
            addNotification({
                title: 'Limit Order Executed',
                message: `Your ${orderType} order for ${order.amount} ${order.symbol} at ${targetPrice} has been executed!`,
                type: 'success',
                playSound: true
              });
              
              // Refresh data
              if (typeof fetchUserBalances === 'function') fetchUserBalances();
              if (typeof fetchPositions === 'function') fetchPositions();
          } else {
              // Add back to pending orders if failed
              setPendingLimitOrders(prev => [...prev, order]);
              
              console.error('Failed to execute limit order:', result.error);
            addNotification({
              title: 'Execution Failed',
              message: `Failed to execute your order: ${result.error}`,
                type: 'error',
                playSound: false
              });
            }
            
            // Remove from being executed tracking
            setOrdersBeingExecuted(prev => prev.filter(id => id !== order.id));
          })
          .catch(error => {
            // Add back to pending orders if failed
            setPendingLimitOrders(prev => [...prev, order]);
            
            console.error('Failed to execute limit order:', error);
          addNotification({
            title: 'Execution Error',
              message: `Error executing your order: ${error.message}`,
              type: 'error',
              playSound: false
            });
            
            // Remove from being executed tracking
            setOrdersBeingExecuted(prev => prev.filter(id => id !== order.id));
          });
      }
    });
  }, [marketPrice, pendingLimitOrders, currentUser, ordersBeingExecuted]);

  // Add a function to calculate liquidation price based on position details
  const calculateLiquidationPrice = (position) => {
    if (!position || !position.type || !position.entryPrice || !position.leverage) {
      return 0;
    }
    
    // Extract position details
    const { type, entryPrice, leverage, margin } = position;
    const entryPriceNum = parseFloat(entryPrice);
    const leverageNum = parseFloat(leverage);
    const marginNum = parseFloat(margin || 0);
    
    if (isNaN(entryPriceNum) || isNaN(leverageNum) || leverageNum === 0 || marginNum === 0) {
      return 0;
    }
    
    // Calculate the liquidation threshold (percentage of margin that triggers liquidation)
    // Typically this is around 80% of the margin, but can vary based on exchange rules
    const liquidationThreshold = 0.8;
    
    // Calculate liquidation price based on position type (buy/long or sell/short)
    if (type.toLowerCase() === 'buy' || type.toLowerCase() === 'long') {
      // For long positions, liquidation happens when price falls
      // Formula: entry_price - (entry_price / leverage) * liquidationThreshold
      return entryPriceNum * (1 - (liquidationThreshold / leverageNum));
    } else {
      // For short positions, liquidation happens when price rises
      // Formula: entry_price + (entry_price / leverage) * liquidationThreshold
      return entryPriceNum * (1 + (liquidationThreshold / leverageNum));
    }
  };

  useEffect(() => {
    console.log("Order type changed to:", orderType);
  }, [orderType]);

  // Create formatTradingData helper without hooks
  const formatTradingData = (crypto) => {
    if (!crypto) return null;
    return {
      token: {
        id: crypto.id,
        name: crypto.name,
        symbol: crypto.symbol?.toUpperCase(),
        type: crypto.type || 'cex',
        image: crypto.icon || crypto.logoUrl || crypto.logo ||
              `https://coinicons-api.vercel.app/api/icon/${crypto.symbol?.toLowerCase()}`,
        contractAddress: crypto.address || crypto.contractAddress,
        chainId: crypto.chainId || crypto.chain || 'bsc'
      },
      pairInfo: crypto.type === 'dex' ? {
        address: crypto.dexData?.pairAddress,
        dexId: crypto.dexData?.dexId,
        chainId: crypto.chainId || crypto.chain || 'bsc',
        priceUsd: parseFloat(crypto.price?.replace?.('$', '') || 0) 
      } : null,
      chartData: {
        price: parseFloat(typeof crypto.price === 'string' ? crypto.price.replace('$', '') : crypto.price) || 0,
        change24h: parseFloat(crypto.sale || 0),
        volume24h: crypto.volume24h,
        marketCap: crypto.cap
      }
    };
  };

  // Regular function for handling result clicks - no hooks here
  const handleResultClick = (result) => {
    if (!result || !result.id) return;
    
    // Log what we're doing
    console.log('Navigating to trading page with data:', result);
    
    // Create the trading data object without using hooks
    const tradingData = formatTradingData(result);
    
    // Use the navigate function from useNavigate hook (declared at component level)
    navigate(`/trading/${result.id}`, { 
      state: { cryptoData: tradingData }
    });
  };

  // Add error handling for missing data - make sure we always have something to display
  if (!cryptoData) {
    return (
      <TradingContainer>
        <h2>Loading trading data...</h2>
      </TradingContainer>
    );
  }

  // Add a function to check if positions should be liquidated based on current market price
  const checkPositionsForLiquidation = async () => {
    if (!currentUser || !marketPrice || openPositions.length === 0) return;
    
    try {
      // First validate the current market price to ensure it's reasonable
      const symbol = cryptoData?.token?.symbol?.toUpperCase() || 'BTC';
      const isValidPrice = validatePrice(marketPrice, symbol);
      
      if (!isValidPrice) {
        console.warn('Skipping liquidation check due to anomalous market price:', marketPrice);
        return; // Don't proceed with liquidations if the price is anomalous
      }
      
      // Don't liquidate if price data consistency is questionable
      if (!isPriceConsistent) {
        console.warn('Skipping liquidation check due to inconsistent price data');
        return;
      }
      
      // Use the median price for liquidation checks for added stability
      const priceForLiquidation = getMedianPrice() || marketPrice;
      
      // Add a timestamp check - don't liquidate if we haven't had stable prices
      // for at least 60 seconds to prevent flash crashes from triggering liquidations
      const now = Date.now();
      if (lastCheckedPrice && (now - lastCheckedPrice < 60000)) {
        console.log('Skipping liquidation check: waiting for price stability period');
        return;
      }
      
      // Update last checked time
      setLastCheckedPrice(now);
      
      // Process each open position
      for (const position of openPositions) {
        // Skip if position type is not defined
        if (!position.type) {
          console.warn(`Position ${position.id} has no type defined, skipping liquidation check`);
          continue;
        }
        
        const liquidationPrice = calculateLiquidationPrice(position);
        
        // Skip if we couldn't calculate a liquidation price
        if (!liquidationPrice) {
          console.warn(`Couldn't calculate liquidation price for position ${position.id}, skipping`);
          continue;
        }
        
        // Additional safeguard: ensure a significant distance from entry price
        // before liquidation to prevent flash crashes from liquidating positions
        const entryPrice = parseFloat(position.entryPrice);
        const priceDiffPercent = Math.abs((priceForLiquidation - entryPrice) / entryPrice * 100);
        
        // Adjust minimum distance based on leverage
        const leverage = parseInt(position.leverage) || 1;
        const minDistancePercent = 60 / leverage; // Higher leverage = lower threshold
        
        // Don't liquidate if we're not far enough from entry price, regardless of calculated liquidation
        if (priceDiffPercent < minDistancePercent) {
          console.log(`Position ${position.id} is close to liquidation but protected by minimum distance safeguard (${priceDiffPercent.toFixed(2)}% vs required ${minDistancePercent.toFixed(2)}%)`);
          continue;
        }
        
        // Check if liquidation condition is met
        const shouldLiquidate = position.type.toLowerCase() === 'buy' 
          ? priceForLiquidation <= liquidationPrice 
          : priceForLiquidation >= liquidationPrice;
        
        if (shouldLiquidate) {
          console.log(`Position ${position.id} is being liquidated at market price ${priceForLiquidation}`);
          
          // Print detailed info for debugging
          console.log(`LIQUIDATION INFO:
            Position: ${position.id}
            Symbol: ${position.symbol || symbol}
            Type: ${position.type}
            Entry Price: ${entryPrice}
            Current Price: ${priceForLiquidation}
            Liquidation Price: ${liquidationPrice}
            Price Difference: ${priceDiffPercent.toFixed(2)}%
            Leverage: ${leverage}x
          `);
          
          try {
            // Log detailed information for audit purposes
            console.log('LIQUIDATION EVENT:', {
              positionId: position.id,
              symbol: position.symbol || symbol,
              type: position.type,
              entryPrice: entryPrice,
              liquidationPrice: liquidationPrice,
              currentPrice: priceForLiquidation,
              leverage: leverage,
              timestamp: new Date().toISOString()
            });
            
            // Double-check the price one more time
            const secondValidation = validatePrice(priceForLiquidation, symbol);
            if (!secondValidation) {
              console.warn(`Aborting liquidation for position ${position.id}: Price validation failed on second check`);
              continue;
            }
            
            // Use the median price for liquidation, not just the current market price
            const result = await tradingService.closePosition(
              currentUser.uid, 
              position.id, 
              priceForLiquidation, 
              true // Mark as liquidation
            );
            
            // Show notification
            addNotification({
              type: 'warning',
              title: 'Position Liquidated',
              message: `Position ${position.symbol || symbol} has been liquidated at ${priceForLiquidation.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} USDT`,
              playSound: true
            });
            
            // Refresh positions
            fetchPositions();
          } catch (error) {
            console.error("Error during liquidation:", error);
          }
        }
      }
    } catch (error) {
      console.error("Error checking for liquidations:", error);
    }
  };
  
  // Monitor price changes for liquidation checks
  useEffect(() => {
    if (marketPrice && openPositions.length > 0) {
      checkPositionsForLiquidation();
    }
  }, [marketPrice, openPositions]);

  // Add this function to refresh prices on page load or when needed
  const fetchAccuratePrice = async () => {
    if (!cryptoData) return;
    
    try {
      const symbol = cryptoData.token?.symbol?.toLowerCase() || 'btc';
      let coinId;
      
      // Map symbols to CoinGecko IDs
      switch (symbol) {
        case 'btc':
        case 'btcusdt':
          coinId = 'bitcoin';
          break;
        case 'eth':
        case 'ethusdt':
          coinId = 'ethereum';
          break;
        default:
          // Try to use symbol as coinId for other tokens
          coinId = symbol.replace('usdt', '');
      }
      
      console.log(`ðŸ”„ Fetching accurate price for ${coinId} from CoinGecko`);
      const response = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`);
      
      if (response.data[coinId] && response.data[coinId].usd) {
        const newPrice = parseFloat(response.data[coinId].usd);
        
        // Validate the price
        const normalizedSymbol = symbol.toUpperCase();
        const isValidPrice = validatePrice(newPrice, normalizedSymbol);
        
        // Update validation state
        setIsPriceValidated(isValidPrice);
        
    const percentChange = Math.abs((newPriceNum - oldPriceNum) / oldPriceNum) * 100;
    
    // Define reasonable max percentage changes per update for different assets
    const maxPercentChanges = {
      'BTC': 2.5,    // Bitcoin is less volatile, max 2.5% in a single update
      'ETH': 3,      // Ethereum slightly more volatile
      'SOL': 5,      // Solana more volatile
      'DOGE': 7,     // Memecoin, much more volatile
      'SHIB': 10     // Small-cap, extremely volatile
    };
    
    // Get appropriate threshold or use 5% as default
    const normalizedSymbol = symbol.replace(/usdt$/i, '').toUpperCase();
    const maxChange = maxPercentChanges[normalizedSymbol] || 5;
    
    // Log large price movements for debugging
    if (percentChange > maxChange * 0.5) {
      console.warn(`Large price movement detected for ${normalizedSymbol}: ${percentChange.toFixed(2)}% change from ${oldPriceNum} to ${newPriceNum}`);
    }
    
    // Return true if movement exceeds threshold
    return percentChange > maxChange;
  };

  // Create a price consistency tracker to maintain a history of recent prices
  const usePriceConsistencyTracker = (initialPrice) => {
    const [priceHistory, setPriceHistory] = useState([initialPrice].filter(Boolean));
    const [suspiciousUpdates, setSuspiciousUpdates] = useState(0);
    const [isConsistent, setIsConsistent] = useState(true);
    
    // Add a new price and validate consistency
    const trackPrice = (newPrice, symbol) => {
      if (!newPrice || isNaN(newPrice)) return false;
      
      const lastPrice = priceHistory.length > 0 ? priceHistory[priceHistory.length - 1] : null;
      
      // Check if this is an extreme price movement
      const isExtreme = lastPrice && isExtremeMarketMovement(lastPrice, newPrice, symbol);
      
      if (isExtreme) {
        console.error(`âš ï¸ EXTREME PRICE MOVEMENT DETECTED: ${lastPrice} -> ${newPrice}`);
        setSuspiciousUpdates(prev => prev + 1);
        
        // If we've seen multiple suspicious updates in a row, mark data as inconsistent
        if (suspiciousUpdates >= 2) {
          setIsConsistent(false);
          return false;
        }
        
        return false; // Reject this update
      } else {
        // Reset suspicious updates counter if we get a normal update
        if (suspiciousUpdates > 0) {
          setSuspiciousUpdates(0);
        }
        
        // If we previously flagged as inconsistent but now getting normal updates,
        // restore consistency after a few good updates
        if (!isConsistent && suspiciousUpdates === 0) {
          setIsConsistent(true);
        }
        
        // Add to price history, keeping only most recent 10 prices
        setPriceHistory(prev => [...prev, newPrice].slice(-10));
        return true;
      }
    };
    
    return { 
      priceHistory, 
      isConsistent, 
      trackPrice,
      getMedianPrice: () => {
        // Get median price from history to filter out anomalies
        if (priceHistory.length === 0) return null;
        const sortedPrices = [...priceHistory].sort((a, b) => a - b);
        const mid = Math.floor(sortedPrices.length / 2);
        return sortedPrices.length % 2 === 0 
          ? (sortedPrices[mid - 1] + sortedPrices[mid]) / 2
          : sortedPrices[mid];
      }
    };
  };

  // Add to the Trading component after state declarations
  const [lastValidatedPrice, setLastValidatedPrice] = useState(null);
  const {
    priceHistory,
    isConsistent: isPriceConsistent,
    trackPrice,
    getMedianPrice
  } = usePriceConsistencyTracker(currentPrice);

  // Modify the websocket message handler to add price validation
      // If position close price differs significantly from position entry price, add a warning
      const entryPriceNum = parseFloat(position.entryPrice);
      const currentPriceNum = parseFloat(priceToUse);
      const priceDiffPercent = Math.abs((currentPriceNum - entryPriceNum) / entryPriceNum * 100);
      
      if (priceDiffPercent > 15) {
        // For large differences, show a confirmation dialog
        const shouldProceed = window.confirm(
          `Warning: This position will be closed at a price that is ${priceDiffPercent.toFixed(2)}% different from your entry price. Are you sure you want to continue?`
        );
        
        if (!shouldProceed) {
          setIsPending(false);
          setClosingPositionId(null);
          throw new Error('Position close cancelled by user');
        }
      }
      
      console.log(`Attempting to close position ${position.id} at price $${priceToUse}`);
      
      // Pass the currentUser.uid as the first parameter with the properly formatted price
      const result = await tradingService.closePosition(currentUser.uid, position.id, priceToUse);
      
      console.log('Position close result:', result);
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to close position');
      } else {
        // Play sound effect on successful position close
        playTradeSound();
      
        // The position will be updated via the Firestore listener
        console.log(`Successfully closed position. PnL: $${result.pnl.toLocaleString()}, Return Amount: $${result.returnAmount.toLocaleString()}`);
      }
    } catch (error) {
      console.error('Error closing position:', error);
      setError(error.message || 'Failed to close position');
    } finally {
      setIsPending(false);
      setClosingPositionId(null);
    }
  };

  // Modify the checkPositionsForLiquidation function to add safeguards
  const checkPositionsForLiquidation = async () => {
    if (!currentUser || !marketPrice || positions.length === 0) return;
    
    try {
      // First validate the current market price to ensure it's reasonable
      const symbol = cryptoData?.token?.symbol?.toUpperCase() || 'BTC';
      const isValidPrice = validatePrice(marketPrice, symbol);
      
      if (!isValidPrice) {
        console.warn('Skipping liquidation check due to anomalous market price:', marketPrice);
        return; // Don't proceed with liquidations if the price is anomalous
      }
      
      // Don't liquidate if price data consistency is questionable
      if (!isPriceConsistent) {
        console.warn('Skipping liquidation check due to inconsistent price data');
        return;
      }
      
      // Use the median price for liquidation checks for added stability
      const priceForLiquidation = getMedianPrice() || marketPrice;
      
      for (const position of positions) {
        const liquidationPrice = calculateLiquidationPrice(position);
        
        // Additional safeguard: ensure a significant distance from entry price
        // before liquidation to prevent flash crashes from liquidating positions
        const entryPrice = parseFloat(position.entryPrice);
        const priceDiffPercent = Math.abs((priceForLiquidation - entryPrice) / entryPrice * 100);
        
        // Adjust minimum distance based on leverage
        const leverage = parseInt(position.leverage) || 1;
        const minDistancePercent = 60 / leverage; // Higher leverage = lower threshold
        
        // Don't liquidate if we're not far enough from entry price, regardless of calculated liquidation
        if (priceDiffPercent < minDistancePercent) {
          console.log(`Position ${position.id} is close to liquidation but protected by minimum distance safeguard (${priceDiffPercent.toFixed(2)}% vs required ${minDistancePercent.toFixed(2)}%)`);
          continue;
        }
        
        // Check if liquidation condition is met
        const shouldLiquidate = position.type === 'buy' 
          ? priceForLiquidation <= liquidationPrice 
          : priceForLiquidation >= liquidationPrice;
        
        if (shouldLiquidate) {
          console.log(`Position ${position.id} is being liquidated at market price ${priceForLiquidation}`);
          try {
            // Log detailed information for audit purposes
            console.log('LIQUIDATION EVENT:', {
              positionId: position.id,
              symbol: position.symbol,
              type: position.type,
              entryPrice: position.entryPrice,
              liquidationPrice: liquidationPrice,
              currentPrice: priceForLiquidation,
              leverage: position.leverage,
              timestamp: new Date().toISOString()
            });
            
            // Use the median price for liquidation, not just the current market price
            const result = await tradingService.closePosition(
              currentUser.uid, 
              position.id, 
              priceForLiquidation, 
              true // Mark as liquidation
            );
            
            // Show notification
            addNotification({
              type: 'warning',
              title: 'Position Liquidated',
              message: `Position ${position.symbol} has been liquidated at ${priceForLiquidation.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} USDT`,
              playSound: true
            });
            
            // Refresh positions
            fetchPositions();
          } catch (err) {
            console.error("Error during liquidation:", err);
          }
        }
      }
    } catch (error) {
      console.error("Error checking for liquidations:", error);
    }
  };

};

export default Trading; 
