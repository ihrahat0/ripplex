import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { useNavigate, useParams, useLocation } from 'react-router-dom';
import styled, { css, keyframes, useTheme } from 'styled-components';
import { Tab, Tabs, TabList, TabPanel } from 'react-tabs';
import 'react-tabs/style/react-tabs.css';
import { db } from '../firebase';
import { 
  collection, 
  addDoc, 
  getDocs, 
  deleteDoc, 
  doc, 
  query, 
  where,
  updateDoc,
  writeBatch,
  getDoc,
  runTransaction,
  setDoc,
  onSnapshot,
  increment,
  serverTimestamp
} from 'firebase/firestore';
import { useAuth } from '../contexts/AuthContext';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import TradingChartComponent from '../components/TradingChart';
import { tradingService } from '../services/tradingService';
import btcIcon from '../assets/images/coin/btc.png';
import LightweightChartComponent from '../components/LightweightChartComponent';
import soundEffect from '../assets/sound/sound-effect.wav';
import lottie from 'lottie-web';
import coinFlipAnimationData from '../assets/animations/coin-flip.json';

// Simple notification function using console.log
const addNotification = ({ title, message, type, playSound = false }) => {
  console.log(`[${type || 'info'}] ${title}: ${message}`);
  // Play sound if requested
  if (playSound) {
    try {
      const audio = new Audio(soundEffect);
      audio.play().catch(error => {
        console.warn('Error playing notification sound:', error);
      });
    } catch (error) {
      console.warn('Error initializing notification sound:', error);
    }
  }
  // In a real app, we would use a proper notification library
};

const TradingContainer = styled.div`
  padding: 20px;
  background: var(--bg1);
  min-height: calc(100vh - 100px);
  margin-top: 10px;
  
  @media (max-width: 768px) {
    padding: 10px;
    margin-top: 5px;
  }
`;

const TradingGrid = styled.div`
  display: grid;
  grid-template-columns: auto 600px;
  gap: 1px;
  margin-top: 105px;
  background: var(--bg);
  
  @media (max-width: 1200px) {
    grid-template-columns: auto 450px;
  }
  
  @media (max-width: 992px) {
    grid-template-columns: 1fr;
  }
  
  @media (max-width: 768px) {
    margin-top: 10px;
  }
`;

const ChartSection = styled.div`
  background: var(--bg);
  border-right: 1px solid var(--line);
  height: 500px;
  
  @media (max-width: 992px) {
    border-right: none;
    border-bottom: 1px solid var(--line);
  }
  
  @media (max-width: 768px) {
    height: 350px;
  }
`;

const RightSection = styled.div`
  width: 600px;
  background: var(--bg);
  display: grid;
  grid-template-rows: auto;
  height: 500px;
  
  @media (max-width: 1200px) {
    width: 450px;
  }
  
  @media (max-width: 992px) {
    width: 100%;
  }
  
  @media (max-width: 768px) {
    height: auto;
  }
`;

const TradingInterface = styled.div`
  display: grid;
  grid-template-columns: 300px 300px;
  border-left: 1px solid var(--line);
  
  @media (max-width: 1200px) {
    grid-template-columns: 225px 225px;
  }
  
  @media (max-width: 992px) {
    grid-template-columns: 1fr 1fr;
    border-left: none;
  }
  
  @media (max-width: 576px) {
    grid-template-columns: 1fr;
  }
`;

const OrderBookSection = styled.div`
  height: 500px;
  border-right: 1px solid var(--line);
  padding: 12px;
  display: flex;
  flex-direction: column;
  
  @media (max-width: 992px) {
    height: 400px;
  }
  
  @media (max-width: 768px) {
    height: 350px;
  }
  
  @media (max-width: 576px) {
    border-right: none;
    border-bottom: 1px solid var(--line);
  }
`;

const OrderFormSection = styled.div`
  padding: 12px;
  height: 500px;
  display: flex;
  flex-direction: column;
  
  @media (max-width: 992px) {
    height: 400px;
  }
  
  @media (max-width: 768px) {
    height: 350px;
    padding: 10px;
  }
`;

const ChartCard = styled.div`
  background: var(--bg);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 20px;
  
  @media (max-width: 768px) {
    padding: 12px;
    border-radius: 8px;
  }
`;

const OrderCard = styled.div`
  background: var(--bg);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 20px;
  height: 100%;
  overflow-y: auto;
  
  @media (max-width: 768px) {
    padding: 12px;
    border-radius: 8px;
  }
`;

const CoinInfo = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 20px;
  
  @media (max-width: 768px) {
    gap: 8px;
    margin-bottom: 15px;
  }
`;

const CoinIcon = styled.img`
  width: 40px;
  height: 40px;
  border-radius: 50%;
  object-fit: contain;
  background: ${props => props.$theme === 'dark' ? '#2A2A3C' : '#fff'};
  padding: 2px;
  
  @media (max-width: 768px) {
    width: 32px;
    height: 32px;
  }
`;

const CoinName = styled.h2`
  color: #fff;
  margin: 0;
  font-size: 24px;
  
  @media (max-width: 768px) {
    font-size: 20px;
  }
`;

const CoinSymbol = styled.span`
  color: #7A7A7A;
  font-size: 16px;
  
  @media (max-width: 768px) {
    font-size: 14px;
  }
`;

const PriceInfo = styled.div`
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
  
  @media (max-width: 768px) {
    gap: 12px;
    margin-bottom: 15px;
    flex-direction: column;
  }
`;

const Price = styled.div`
  color: #fff;
  font-size: 24px;
  font-weight: 500;
  
  @media (max-width: 768px) {
    font-size: 20px;
  }
`;

const Change = styled.span`
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 14px;
  background: ${props => props.$isPositive ? 'rgba(14, 203, 129, 0.2)' : 'rgba(246, 70, 93, 0.2)'};
  color: ${props => props.$isPositive ? '#0ECB81' : '#F6465D'};
  margin-left: 8px;
  
  @media (max-width: 768px) {
    font-size: 12px;
    padding: 1px 6px;
  }
`;

const OrderForm = styled.form`
  display: flex;
  flex-direction: column;
  gap: 12px;
  height: 100%;
  
  @media (max-width: 768px) {
    gap: 8px;
  }
`;

const TabGroup = styled.div`
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
  border-bottom: 1px solid var(--line);
  padding-bottom: 10px;
  
  @media (max-width: 768px) {
    gap: 4px;
    margin-bottom: 12px;
    padding-bottom: 8px;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    
    &::-webkit-scrollbar {
      display: none;
    }
  }
`;

const OrderTab = styled.button`
  background: none;
  border: none;
  padding: 12px;
  cursor: pointer;
  font-size: 16px;
  font-weight: 500;
  outline: none;
  color: ${props => props.$active ? 'var(--primary)' : 'var(--text)'};
  opacity: 0.9;
  transition: all 0.2s;
  border-bottom: 2px solid ${props => props.$active ? 'var(--primary)' : 'transparent'};

  &:hover {
    opacity: 1;
  }
  
  @media (max-width: 768px) {
    padding: 8px;
    font-size: 14px;
    white-space: nowrap;
  }
`;

const AmountInput = styled.input`
  width: 100%;
  padding: 8px 12px;
  margin: 8px 0;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg2);
  color: var(--text);
  font-size: 14px;
  outline: none;
  transition: all 0.3s ease;

  &:focus {
    border-color: var(--primary);
  }

  @media (max-width: 768px) {
    padding: 6px 10px;
    margin: 6px 0;
    font-size: 13px;
  }
`;

const Button = styled.button`
  background: var(--primary);
  color: #fff;
  border: none;
  border-radius: 8px;
  padding: 14px;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.3s;

  &:hover {
    opacity: 0.9;
  }
`;

// Update the TIMEFRAMES object
const TIMEFRAMES = {
  '1D': { label: '1D', value: '1' },
  '1W': { label: '1W', value: '7' }
};

// Update the styled component for the chart
const ChartEmbed = styled.iframe`
  width: 100%;
  height: 600px;
  border: none;
  border-radius: 8px;
  background: var(--bg2);
`;

const CurrentPrice = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 16px;
  padding: 8px 0;
  margin: 5px 0;
  position: relative;
  color: ${props => props.$isUp ? '#0ECB81' : '#F6465D'};
  background: ${props => props.$isUp ? 'rgba(14, 203, 129, 0.15)' : 'rgba(246, 70, 93, 0.15)'};
  border-top: 1px solid ${props => props.$isUp ? 'rgba(14, 203, 129, 0.3)' : 'rgba(246, 70, 93, 0.3)'};
  border-bottom: 1px solid ${props => props.$isUp ? 'rgba(14, 203, 129, 0.3)' : 'rgba(246, 70, 93, 0.3)'};
  letter-spacing: 0.5px;
`;

// Replace the InternalTradingChart function
function InternalTradingChart({ symbol, theme }) {
  return (
    <TradingChartComponent
      symbol={`BINANCE:${symbol}`}
      theme={theme}
      container_id="tradingview_chart"
      autosize={true}
      timeframe="15"
      allow_symbol_change={false}
    />
  );
}

// Define accurate coin IDs for CoinGecko
const hardcodedPrices = {
  'btc': 90812.45,
  'bitcoin': 90812.45,
  'eth': 3452.67,
  'ethereum': 3452.67,
  'sol': 142.56,
  'bnb': 567.89,
  'doge': 0.12
};

// Define accurate coin IDs for CoinGecko
const COINGECKO_IDS = {
  'btc': 'bitcoin',
  'bitcoin': 'bitcoin',
  'eth': 'ethereum', 
  'ethereum': 'ethereum',
  'sol': 'solana',
  'bnb': 'binancecoin',
  'doge': 'dogecoin',
  'xrp': 'ripple',
  'ada': 'cardano',
  'dot': 'polkadot',
  'matic': 'matic-network',
  'avax': 'avalanche-2',
  'link': 'chainlink',
  'uni': 'uniswap',
  'atom': 'cosmos'
};

const fetchHistoricalData = async (coinId, days = '1', interval = 'minute') => {
  try {
    const response = await fetch(
      `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=${days}&interval=${interval}`
    );
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    
    // Convert the data to candlestick format
    const candlesticks = [];
    const prices = data.prices;
    
    for (let i = 0; i < prices.length; i += 1) {
      const candle = {
        time: prices[i][0] / 1000, // Convert to seconds
        open: prices[i][1],
        high: prices[i][1],
        low: prices[i][1],
        close: prices[i][1]
      };
      
      if (i > 0) {
        candle.open = prices[i-1][1];
        candle.high = Math.max(candle.open, candle.close);
        candle.low = Math.min(candle.open, candle.close);
      }
      
      candlesticks.push(candle);
    }
    
    return candlesticks;
  } catch (error) {
    console.error('Error fetching historical data:', error);
    return null;
  }
};

// Add these new styled components
const OrderTypeSelector = styled.div`
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
`;

const leverageOptions = [10, 20, 25, 30, 40];  // Updated leverage options

const LeverageSlider = styled.input`
  -webkit-appearance: none;
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: var(--bg2);
  outline: none;
  margin: 10px 0;
  
  &::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: ${props => props.$value >= 30 ? '#F6465D' : 'var(--primary)'};
    cursor: pointer;
  }
  
  &::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: ${props => props.$value >= 30 ? '#F6465D' : 'var(--primary)'};
    cursor: pointer;
    border: none;
  }
`;

const LeverageDisplay = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 4px;
  color: var(--text);
  font-size: 12px;
`;

const QuickLeverageButtons = styled.div`
  display: flex;
  gap: 4px;
  margin-top: 4px;
`;

const QuickLeverageButton = styled.button`
  padding: 4px 8px;
  margin: 0 4px;
  border-radius: 4px;
  border: none;
  font-size: 12px;
  cursor: pointer;
  transition: background 0.2s;
  background: ${props => props.$active ? 'var(--primary)' : 'var(--bg1)'};
  color: ${props => props.$active ? '#fff' : 'var(--text)'};
  
  &:hover {
    background: var(--primary);
    color: #fff;
  }
`;

const OrderDetails = styled.div`
  margin-top: 16px;
  padding: 16px;
  background: var(--bg1);
  border-radius: 8px;
`;

const DetailRow = styled.div`
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  color: var(--text);
  font-size: 14px;
`;

// Add these new styled components
const OrderBook = styled.div`
  height: 100%;
  display: flex;
  flex-direction: column;
  background: var(--bg2);
  border-radius: 4px;
  
  @media (max-width: 768px) {
    max-height: 300px;
    overflow-y: auto;
  }
`;

const OrderBookHeader = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  color: #7A7A7A;
  font-size: 11px;
  padding: 4px 8px;
  border-bottom: 1px solid var(--line);
  margin-bottom: 2px;

  & > span:nth-child(2),
  & > span:last-child {
    text-align: right;
  }
  
  @media (max-width: 768px) {
    font-size: 10px;
    padding: 3px 6px;
  }
`;

const OrderBookRow = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  padding: 2px 8px;
  font-size: 11px;
  cursor: pointer;
  position: relative;
  height: 20px;
  line-height: 20px;
  color: var(--text);
  
  &:hover {
  background: ${props => props.$side === 'sell' ? 'rgba(246, 70, 93, 0.1)' : 'rgba(14, 203, 129, 0.1)'};
  }
  
  &::before {
    content: '';
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    width: ${props => props.$depth || 0}%;
    background: ${props => props.$side === 'sell' ? 'rgba(246, 70, 93, 0.05)' : 'rgba(14, 203, 129, 0.05)'};
    z-index: 0;
  }

  & > span {
    position: relative;
    z-index: 1;
    &:nth-child(2),
    &:last-child {
      text-align: right;
    }
  }
  
  /* Add subtle animations for updates */
  &.flash {
    animation: flashUpdate 0.5s ease-out;
  }
  
  @keyframes flashUpdate {
    0% {
      background: ${props => props.$side === 'sell' ? 'rgba(246, 70, 93, 0.3)' : 'rgba(14, 203, 129, 0.3)'};
    }
    100% {
      background: transparent;
    }
  }
`;

// Update OrderCard to include buy/sell colors
const OrderButton = styled.button`
  background: ${props => props.$orderType === 'buy' ? '#0ECB81' : '#F6465D'};
  color: white;
  border: none;
  padding: 12px;
  border-radius: 4px;
  cursor: pointer;
  width: 100%;
  font-weight: 500;
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

// Add a new container for the right side
const RightPanel = styled.div`
  display: grid;
  grid-template-rows: 1fr 1fr;
  gap: 20px;
  height: 600px; // Match chart height
`;

// Update the positions table styling
const PositionsTable = styled.table`
  width: 100%;
  color: var(--text);
  border-collapse: collapse;
  background: var(--bg);
  border-radius: 8px;
  margin-top: 105px;
`;

const TableHeader = styled.th`
  padding: 12px;
  text-align: left;
  border-bottom: 1px solid var(--line);
  font-weight: 500;
  color: #7A7A7A;
`;

const TableCell = styled.td`
  padding: 12px;
  border-bottom: 1px solid var(--line);
`;

const PnLValue = styled.span`
  font-weight: 500;
  color: ${props => props.$value >= 0 ? '#0ECB81' : '#F6465D'};
`;

// Add these styled components at the top with your other styled components
const TradeInfo = styled.div`
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 15px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  margin: 10px 0;
`;

const InfoItem = styled.div`
  display: flex;
  justify-content: space-between;
  color: ${props => props.$highlight ? '#00C087' : '#fff'};
  font-size: 14px;
`;

// Add this helper function before the Trading component
const calculateRequiredMargin = (amount, price, leverage) => {
  if (!amount || !price || !leverage) return 0;
  return (parseFloat(amount) * price) / leverage;
};

// Update the leverage buttons handling
const LeverageButtons = styled.div`
  display: flex;
  gap: 8px;
  margin-top: 8px;
`;

const LeverageInput = styled.input`
  width: 100%;
  padding: 8px;
  margin-top: 8px;
  background: var(--bg2);
  border: 1px solid var(--line);
  color: var(--text);
  border-radius: 4px;
`;

// Add these styled components
const ChartContainer = styled.div`
  position: relative;
  background: var(--bg1);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 20px;
`;

const DexLink = styled.a`
  display: inline-block;
  padding: 8px 12px;
  background: rgba(30, 34, 45, 0.8);
  color: var(--text-secondary);
  font-size: 13px;
  text-decoration: none;
  border-radius: 4px;
  position: absolute;
  right: 24px;
  bottom: 24px;
  transition: all 0.2s;
  
  &:hover {
    background: var(--primary);
    color: white;
  }
  
  i {
    margin-left: 5px;
    font-size: 12px;
  }
`;

const TimeframeSelector = styled.div`
  display: flex;
  gap: 4px;
  padding: 8px;
  position: absolute;
  top: 8px;
  right: 8px;
  z-index: 2;
  background: rgba(30, 34, 45, 0.8);
  border-radius: 4px;
`;

const TimeButton = styled.button`
  padding: 4px 12px;
  background: ${props => props.$active ? 'var(--primary)' : 'transparent'};
  color: ${props => props.$active ? 'white' : '#7a7a7a'};
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s;

  &:hover {
    color: white;
    background: ${props => props.$active ? 'var(--primary)' : 'rgba(71, 77, 87, 0.7)'};
  }
`;

// Add this styled component
const DexScreenerChart = styled.iframe`
  width: 100%;
  height: 500px;
  border: none;
  border-radius: 8px;
  background: var(--bg2);
`;

// Add these new styled components after the existing styled components
const TradesList = styled.div`
  max-height: 80px;
  overflow-y: auto;
  padding: 4px 0;
  background: var(--bg);
  border-top: none;
  border-bottom: none;
  &::-webkit-scrollbar {
    width: 5px;
  }
  &::-webkit-scrollbar-thumb {
    background: rgba(128, 128, 128, 0.3);
    border-radius: 4px;
  }
`;

const TradeRow = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  padding: 4px 8px;
  font-size: 12px;
  animation: fadeIn 0.3s ease-in-out;
  
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateX(${props => props.$isBuy ? '-10px' : '10px'});
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  & > span {
    &:first-child {
      color: ${props => props.$isBuy ? '#0ECB81' : '#F6465D'};
    }
    &:nth-child(2),
    &:last-child {
      text-align: right;
    }
  }
`;

// Add these styled components after the existing styled components
const OrderBookContent = styled.div`
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  height: calc(100% - 32px);
`;

const AsksContainer = styled.div`
  flex: 1;
  overflow-y: auto;
  /* Use more subtle background with less opacity */
  background: var(--bg); 
  display: flex;
  flex-direction: column-reverse;
  min-height: 200px;
  &::-webkit-scrollbar {
    width: 5px;
  }
  &::-webkit-scrollbar-thumb {
    background: rgba(246, 70, 93, 0.1);
    border-radius: 4px;
  }
`;

const BidsContainer = styled.div`
  flex: 1;
  overflow-y: auto;
  /* Use same background as AsksContainer */
  background: var(--bg);
  min-height: 200px;
  &::-webkit-scrollbar {
    width: 5px;
  }
  &::-webkit-scrollbar-thumb {
    background: rgba(14, 203, 129, 0.1);
    border-radius: 4px;
  }
`;

// Fix the calculatePnL function
const calculatePnL = (position, currentMarketPrice) => {
  if (!position || !position.entryPrice || !currentMarketPrice) return 0;
  
  const { type, entryPrice, leverage, margin } = position;
  
  try {
    if (type === 'buy') {
      const priceDiff = currentMarketPrice - entryPrice;
      const percentageChange = (priceDiff / entryPrice) * 100;
      return Number((margin * (percentageChange / 100) * leverage).toLocaleString());
    } else {
      const priceDiff = entryPrice - currentMarketPrice;
      const percentageChange = (priceDiff / entryPrice) * 100;
      return Number((margin * (percentageChange / 100) * leverage).toLocaleString());
    }
  } catch (error) {
    console.error('Error calculating PnL:', error);
    return 0;
  }
};

// Generate order book data with extremely tight spreads that adapt to the token price
const generateOrderBook = (currentPrice, depthCount = 10) => {
  if (!currentPrice || isNaN(currentPrice) || currentPrice <= 0) {
    console.warn('Invalid current price for order book generation:', currentPrice);
    currentPrice = 100; // Reasonable fallback
  }
  
  // Dynamically adjust the price step based on the token's price
  let PRICE_STEP_PERCENT;
  
  // For very small prices (like many DEX tokens)
  if (currentPrice < 0.00001) {
    PRICE_STEP_PERCENT = 0.01; // 1% step for micropriced tokens
  } 
  // For small prices
  else if (currentPrice < 0.001) {
    PRICE_STEP_PERCENT = 0.005; // 0.5% step for small tokens
  }
  // For medium prices 
  else if (currentPrice < 1) {
    PRICE_STEP_PERCENT = 0.002; // 0.2% step
  }
  // For normal prices
  else if (currentPrice < 1000) {
    PRICE_STEP_PERCENT = 0.001; // 0.1% standard step
  }
  // For high-value assets
  else {
    PRICE_STEP_PERCENT = 0.0005; // 0.05% for high-value assets
  }
  
  // Function to format price with appropriate decimals based on price range
  const formatPrice = (price) => {
    if (price < 0.00000001) return parseFloat(price.toFixed(12));
    if (price < 0.0000001) return parseFloat(price.toFixed(11));
    if (price < 0.000001) return parseFloat(price.toFixed(10));
    if (price < 0.00001) return parseFloat(price.toFixed(9));
    if (price < 0.0001) return parseFloat(price.toFixed(8));
    if (price < 0.001) return parseFloat(price.toFixed(7));
    if (price < 0.01) return parseFloat(price.toFixed(6));
    if (price < 0.1) return parseFloat(price.toFixed(5));
    if (price < 1) return parseFloat(price.toFixed(4));
    if (price < 10) return parseFloat(price.toFixed(3));
    if (price < 100) return parseFloat(price.toFixed(2));
    if (price < 1000) return parseFloat(price.toFixed(1));
    return parseFloat(price.toFixed(0));
  };
  
  // Create ask prices (sells above current price)
  const asks = [];
  for (let i = 0; i < depthCount; i++) {
    // Calculate price step based on token price range
    const priceMultiplier = 1 + (PRICE_STEP_PERCENT * (i + 1));
    const rawPrice = currentPrice * priceMultiplier;
    const price = formatPrice(rawPrice);
    
    // Generate realistic volume (higher near current price)
    const volumeBase = 5 / (i + 1);
    const amount = parseFloat((volumeBase * (0.95 + Math.random() * 0.1)).toFixed(4));
    const total = parseFloat((price * amount).toFixed(4));
    
    asks.push({ price, amount, total });
  }
  
  // Create bid prices (buys below current price)
  const bids = [];
  for (let i = 0; i < depthCount; i++) {
    // Calculate price step based on token price range
    const priceMultiplier = 1 - (PRICE_STEP_PERCENT * (i + 1));
    const rawPrice = currentPrice * priceMultiplier;
    const price = formatPrice(rawPrice);
    
    // Generate realistic volume (higher near current price)
    const volumeBase = 5 / (i + 1);
    const amount = parseFloat((volumeBase * (0.95 + Math.random() * 0.1)).toFixed(4));
    const total = parseFloat((price * amount).toFixed(4));
    
    bids.push({ price, amount, total });
  }
  
  return {
    asks,
    bids,
    marketPrice: formatPrice(currentPrice)
  };
};

// Export a single function for order book data that everyone will use
const createOrderBookData = (marketPrice, buyRatio = 0.5) => {
  // Check if we have a valid market price
  if (!marketPrice || isNaN(parseFloat(marketPrice)) || parseFloat(marketPrice) <= 0) {
    // Try to get price from cryptoData if available
    const fallbackPrice = cryptoData?.chartData?.lastPrice;
    
    // If we still don't have a valid price, return empty data
    if (!fallbackPrice || isNaN(parseFloat(fallbackPrice)) || parseFloat(fallbackPrice) <= 0) {
      console.warn('Invalid price for order book generation:', marketPrice);
      return { asks: [], bids: [] };
    }
    
    // Use fallback price
    marketPrice = parseFloat(fallbackPrice);
  } else {
    marketPrice = parseFloat(marketPrice);
  }
  
  // Generate order book with proper price
  const { asks, bids } = generateOrderBook(marketPrice);
  
  // Normalize the buyRatio to be between 0.3 and 0.7 (ensures both sides have volume)
  const normalizedBuyRatio = 0.3 + (buyRatio * 0.4);
  
  // Adjust ask and bid amounts based on buy ratio
  const adjustedAsks = asks.map(ask => {
    const adjustedAmount = ask.amount * (1 - normalizedBuyRatio) * 2; // Lower buys, reduce asks
    return {
      ...ask,
      amount: parseFloat(adjustedAmount.toFixed(4)),
      total: parseFloat((ask.price * adjustedAmount).toFixed(4))
    };
  });
  
  const adjustedBids = bids.map(bid => {
    const adjustedAmount = bid.amount * normalizedBuyRatio * 2; // Higher buys, increase bids
    return {
      ...bid,
      amount: parseFloat(adjustedAmount.toFixed(4)),
      total: parseFloat((bid.price * adjustedAmount).toFixed(4))
    };
  });
  
  return { asks: adjustedAsks, bids: adjustedBids };
};

// Replace all existing functions with this single implementation
const generateMockOrderBookData = createOrderBookData;
const generateDummyOrders = createOrderBookData;

// Helper function to safely cleanup resources
const safelyCleanup = (resource) => {
  if (resource && typeof resource === 'function') {
    try {
      resource();
    } catch (error) {
      console.error('Error during cleanup:', error);
    }
  } else if (resource && typeof resource.destroy === 'function') {
    try {
      resource.destroy();
    } catch (error) {
      console.error('Error destroying resource:', error);
    }
  } else if (resource && typeof resource.close === 'function') {
    try {
      resource.close();
    } catch (error) {
      console.error('Error closing resource:', error);
    }
  }
};

/**
 * Generates a random updated price based on the current price with realistic volatility
 * @param {number} currentPrice - The current market price
 * @returns {number} - A new price with slight random variation
 */
const getRandomUpdatedPrice = (currentPrice) => {
  if (!currentPrice || currentPrice <= 0) return 0.04;
  
  // Smaller price changes for more stable updates
  const volatilityPercentage = 0.002; // Max 0.2% change per update
  const changePercent = (Math.random() * 2 - 1) * volatilityPercentage;
  
  // Calculate new price
  let newPrice = currentPrice * (1 + changePercent);
  
  // Ensure price doesn't drop below minimum values
  if (newPrice < 0.01) {
    newPrice = Math.max(newPrice, 0.01);
  }
  
  // Round appropriately based on price magnitude
  if (newPrice < 0.1) {
    return Math.round(newPrice * 100000) / 100000;
  } else if (newPrice < 1) {
    return Math.round(newPrice * 10000) / 10000;
  } else if (newPrice < 10) {
    return Math.round(newPrice * 1000) / 1000;
  } else if (newPrice < 100) {
    return Math.round(newPrice * 100) / 100;
  }
  
  return Math.round(newPrice * 10) / 10;
};

// Add a function to play sound effect
const playTradeSound = () => {
  try {
    const audio = new Audio(soundEffect);
    audio.play().catch(error => {
      console.warn('Error playing trade sound:', error);
    });
  } catch (error) {
    console.warn('Error initializing trade sound:', error);
  }
};

// Add improved function to format small numbers for display
const formatSmallNumber = (num) => {
  if (num === null || num === undefined || isNaN(num)) {
    return '0.00';
  }
  
  const value = parseFloat(num);
  
  // Format based on size
  if (value === 0) {
    return '0.00';
  } else if (value < 0.00000001) {
    // Extremely small numbers use scientific notation
    return value.toExponential(8);
  } else if (value < 0.0000001) {
    return value.toFixed(10);
  } else if (value < 0.000001) {
    return value.toFixed(9);
  } else if (value < 0.00001) {
    return value.toFixed(8);
  } else if (value < 0.0001) {
    return value.toFixed(7);
  } else if (value < 0.001) {
    return value.toFixed(6);
  } else if (value < 0.01) {
    return value.toFixed(5);
  } else if (value < 0.1) {
    return value.toFixed(4);
  } else if (value < 1) {
    return value.toFixed(4);
  } else if (value < 10) {
    return value.toFixed(3);
  } else if (value < 1000) {
    return value.toFixed(2);
  } else if (value < 10000) {
    return value.toLocaleString(undefined, { maximumFractionDigits: 1 });
  } else {
    return value.toLocaleString(undefined, { maximumFractionDigits: 0 });
  }
};

function Trading() {
  const { cryptoId } = useParams();
  const location = useLocation();
  const navigate = useNavigate();
  const [cryptoData, setCryptoData] = useState(null);
  const [marketPrice, setMarketPrice] = useState(0);
  const [lastPrice, setLastPrice] = useState(0);
  const [currentPrice, setCurrentPrice] = useState(0);
  const [orderBook, setOrderBook] = useState(generateDummyOrders(marketPrice));
  const [orderType, setOrderType] = useState('buy');
  const [orderMode, setOrderMode] = useState('market');
  const [amount, setAmount] = useState('');
  const [limitPrice, setLimitPrice] = useState('');
  const [leverage, setLeverage] = useState(1);
  const [pendingLimitOrders, setPendingLimitOrders] = useState([]);
  const [openPositions, setOpenPositions] = useState([]);
  const [closedPositions, setClosedPositions] = useState([]);
  const [isLoadingBalance, setIsLoadingBalance] = useState(true);
  const [userBalance, setUserBalance] = useState(null);
  const [isLoadingPositions, setIsLoadingPositions] = useState(true);
  const [positions, setPositions] = useState([]);
  const [ordersBeingExecuted, setOrdersBeingExecuted] = useState([]);
  const [isPending, setIsPending] = useState(false);
  const [error, setError] = useState(null);
  const [isOnline, setIsOnline] = useState(true);
  const [showDebug, setShowDebug] = useState(false);
  const [inputKey, setInputKey] = useState(0);
  const [editTargetPrice, setEditTargetPrice] = useState('');
  const [editingOrderId, setEditingOrderId] = useState(null);
  const [orderBookFlash, setOrderBookFlash] = useState({});
  const [timeframe, setTimeframe] = useState('1D');
  const [chartKey, setChartKey] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingData, setIsLoadingData] = useState(true);
  const [isLoadingUser, setIsLoadingUser] = useState(true);
  const [isLoadingPositionsData, setIsLoadingPositionsData] = useState(true);
  const [isLoadingPendingOrders, setIsLoadingPendingOrders] = useState(true);
  const [isLoadingTrades, setIsLoadingTrades] = useState(true);
  const [isLoadingRecentTrades, setIsLoadingRecentTrades] = useState(true);
  const [isLoadingOrderBook, setIsLoadingOrderBook] = useState(true);
  const [isLoadingTradeInfo, setIsLoadingTradeInfo] = useState(true);
  const [isLoadingTradeDetails, setIsLoadingTradeDetails] = useState(true);
  const [isLoadingTradeHistory, setIsLoadingTradeHistory] = useState(true);
  const [isLoadingTradeDetailsData, setIsLoadingTradeDetailsData] = useState(true);
  const [isLoadingTradeHistoryData, setIsLoadingTradeHistoryData] = useState(true);
  
  // Various refs for cleanup
  const ws = useRef(null);
  const priceUpdateInterval = useRef(null);
  const tradeGenerationInterval = useRef(null);
  const orderBookUpdateInterval = useRef(null);
  const positionUpdateInterval = useRef(null);
  
  // useEffect for updating market price from crypto data
  useEffect(() => {
    updateMarketPriceFromCryptoData();
  }, [cryptoData]);
  
  const updateMarketPriceFromCryptoData = async () => {
    if (!cryptoData) return;
    
    if (cryptoData.token?.type === 'dex') {
      // DEX token price handling
      if (cryptoData.chartData?.price || cryptoData.chartData?.lastPrice) {
        const chartPrice = cryptoData.chartData?.price || cryptoData.chartData?.lastPrice;
        console.log("Chart price from DEX data:", chartPrice);
        
        if (!isNaN(parseFloat(chartPrice)) && parseFloat(chartPrice) > 0) {
          const price = parseFloat(chartPrice);
          setMarketPrice(price);
          checkLimitOrders(price);
        } else {
          console.warn('Invalid price received from DEX API:', chartPrice);
        }
      } else if (cryptoData.pairInfo?.priceUsd) {
        try {
          const price = parseFloat(cryptoData.pairInfo.priceUsd);
          if (!isNaN(price) && price > 0) {
            setMarketPrice(price);
            checkLimitOrders(price);
          } else {
            console.warn('Invalid price received from DEX API:', cryptoData.pairInfo.priceUsd);
          }
        } catch (error) {
          console.error('Error fetching DEX price:', error);
        }
      }
    } else {
      // Use CoinGecko API for reliable CEX prices
      try {
        const symbol = cryptoData?.token?.symbol?.toLowerCase() || 'btc';
        let coinId;
        
        // Map symbols to CoinGecko IDs
        switch (symbol) {
          case 'btc':
          case 'btcusdt':
            coinId = 'bitcoin';
            break;
          case 'eth':
          case 'ethusdt':
            coinId = 'ethereum';
            break;
          default:
            // Try to use symbol as coinId for other tokens
            coinId = symbol.replace('usdt', '');
        }
        
        console.log(`Fetching price for ${coinId} from CoinGecko`);
        const response = await axios.get(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`);
        
        if (response.data[coinId] && response.data[coinId].usd) {
          const newPrice = parseFloat(response.data[coinId].usd);
          if (!isNaN(newPrice) && newPrice > 0) {
            console.log(`Received price update for ${coinId}:`, newPrice);
            setMarketPrice(newPrice);
            setLastPrice(newPrice);
            setCurrentPrice(newPrice);
            setOrderBook(generateDummyOrders(newPrice));
            
            // Also set up a WebSocket for real-time updates if available
            setupWebSocketConnection(symbol.toLowerCase());
          }
        } else {
          console.warn('Failed to get price from CoinGecko, falling back to Binance WebSocket');
          setupWebSocketConnection(symbol.toLowerCase());
        }
      } catch (error) {
        console.error('Error fetching price from CoinGecko:', error);
        
        // Fallback to Binance WebSocket
        const symbol = cryptoData?.token?.symbol?.toLowerCase() || 'btcusdt';
        setupWebSocketConnection(symbol.toLowerCase());
      }
    }
  };
  
  const setupWebSocketConnection = (symbol) => {
    // Ensure symbol has usdt suffix
    const formattedSymbol = symbol.endsWith('usdt') ? symbol : `${symbol}usdt`;
    
    console.log('Setting up WebSocket for symbol:', formattedSymbol);
    
    // Close existing connection
    if (ws.current) {
      ws.current.close();
    }
    
    // Create new connection
    ws.current = new WebSocket(`wss://stream.binance.com:9443/ws/${formattedSymbol}@trade`);
      
      ws.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.p) {
            const newPrice = parseFloat(data.p);
            if (!isNaN(newPrice) && newPrice > 0) {
            console.log(`Received WebSocket price update for ${formattedSymbol}:`, newPrice);
              setMarketPrice(newPrice);
              setLastPrice(newPrice);
              setCurrentPrice(newPrice);
              setOrderBook(generateDummyOrders(newPrice));
            } else {
              console.warn('Invalid price received from WebSocket:', data.p);
            }
    }
  } catch (error) {
          console.error('Error processing WebSocket message:', error);
        }
      };

      ws.current.onerror = (error) => {
        console.error('WebSocket error:', error);
      };
    
    ws.current.onclose = () => {
      console.log('WebSocket connection closed');
    };
  };

  // Initialize price update
  updatePrice();

  // Set up periodic updates every 30 seconds as a fallback
  const interval = setInterval(updatePrice, 30000);

  return () => {
    if (ws.current) {
      ws.current.close();
    }
    if (interval) {
      clearInterval(interval);
    }
  };
}, [cryptoData]);

  // useEffect for WebSocket connection and price updates
  useEffect(() => {
    if (!cryptoData || !cryptoData.token) return;
    
    console.log("Setting up WebSocket and price updates for", cryptoData.token.symbol);
    
    // Setup WebSocket connection
    const symbol = cryptoData.token?.symbol?.toLowerCase() || 'btc';
    if (typeof setupWebSocketConnection === 'function') {
      setupWebSocketConnection(symbol);
    }
    
    // Set up periodic updates
    const interval = setInterval(() => {
      updateMarketPriceFromCryptoData();
    }, 30000);
    
    // Return cleanup function
    return () => {
      if (ws.current) {
        ws.current.close();
      }
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [cryptoData]);

  // Setup WebSocket for price updates
  useEffect(() => {
    // Skip if we don't have crypto data
    if (!cryptoData || !cryptoData.token) return;
  
    const updatePrice = () => {
      // Implement price update logic
      console.log('Updating price for', cryptoData.token.symbol);
    };
    
    // Setup WebSocket connection for price updates
    const symbol = cryptoData.token?.symbol?.toLowerCase() || 'btc';
    setupWebSocketConnection(symbol);
    
    // Initialize price update
    updatePrice();
    
    // Set up periodic updates every 30 seconds as a fallback
    const interval = setInterval(updatePrice, 30000);
    
    return () => {
      if (ws.current) {
        ws.current.close();
      }
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [cryptoData]);

  // Define fetchUserData function before it's used in any useEffect
  const fetchUserData = useCallback(async () => {
    if (!currentUser) return () => {};  // Return empty cleanup function
    
    try {
      // Listen to user balance changes
      const userUnsubscribe = onSnapshot(
        doc(db, 'users', currentUser.uid),
        {
          includeMetadataChanges: true
        },
        (doc) => {
          if (doc.exists()) {
            const userData = doc.data();
            console.log('Full user data:', userData);
            
            // Check if balances exist in the user document
            if (userData.balances) {
              console.log('User balances from document:', userData.balances);
              console.log('USDT balance type:', typeof userData.balances.USDT, 'value:', userData.balances.USDT);
              
              // Ensure USDT exists and is a valid number
              if (userData.balances.USDT === undefined || userData.balances.USDT === null || isNaN(userData.balances.USDT)) {
                console.warn('Invalid USDT balance in user document, setting to 0');
                userData.balances.USDT = 0;
              }
              
              setUserBalance(userData.balances);
            } else {
              // No balances in user document
              console.warn('No balances field in user document, will be fixed by ensureUserBalances');
              setUserBalance({ USDT: 0, BTC: 0, ETH: 0 });
            }
            
            setIsLoadingBalance(false);
          }
        },
        (error) => console.error('User snapshot error:', error)
      );

      // Listen to positions
      const positionsUnsubscribe = onSnapshot(
        query(collection(db, 'positions'), where('userId', '==', currentUser.uid)),
        {
          includeMetadataChanges: true
        },
        (snapshot) => {
          const openPos = [];
          const closedPos = [];
          
          snapshot.docs.forEach(doc => {
            const data = doc.data();
            const position = {
        id: doc.id,
              ...data,
              openTime: data.openTime?.toDate?.() || new Date(data.openTime),
              closeTime: data.closeTime?.toDate?.() || (data.closeTime ? new Date(data.closeTime) : null),
              lastUpdated: data.lastUpdated?.toDate?.() || new Date(data.lastUpdated)
            };

            if (position.status === 'OPEN') {
              openPos.push(position);
            } else if (position.status === 'CLOSED') {
              closedPos.push(position);
            }
          });

          setOpenPositions(openPos.sort((a, b) => b.openTime - a.openTime));
          setClosedPositions(closedPos.sort((a, b) => b.closeTime - a.closeTime));
      setIsLoadingPositions(false);
        },
        (error) => console.error('Positions snapshot error:', error)
      );

      // Return a cleanup function that calls both unsubscribe functions
      return () => {
        userUnsubscribe();
        positionsUnsubscribe();
      };
    } catch (error) {
      console.error('Error in fetchUserData:', error);
      return () => {}; // Return empty cleanup function
    }
  }, [currentUser]);

  // Define fetchPriceData function before any useEffect that uses it
  const fetchPriceData = useCallback(async () => {
    if (!cryptoData?.token) {
      console.warn('No token data available for fetchPriceData');
      return;
    }

    try {
      if (cryptoData.token.type === 'dex') {
        // For DEX tokens, use DexScreener API's standard pairs endpoint
        const chain = cryptoData.token.chainId?.toLowerCase() || 'ethereum';
        const pairAddress = cryptoData.pairInfo?.address?.toLowerCase();
        
        if (!pairAddress) {
          console.error('No pair address available for DEX token');
          setPriceData([]);
          return;
        }
        
        console.log(`Fetching price data for ${chain}/${pairAddress}`);
        
        // Try both format options to ensure we get data
        let response;
        try {
          // First attempt: Use pairs/{chain}/{pairAddress} format
          response = await axios.get(
            `https://api.dexscreener.com/latest/dex/pairs/${chain}/${pairAddress}`
          );
          console.log('DexScreener API response (pairs endpoint):', response.data);
        } catch (error) {
          console.error('Error fetching from DexScreener pairs endpoint:', error);
          
          // Second attempt: Use direct address endpoint
          try {
            response = await axios.get(
              `https://api.dexscreener.com/latest/dex/search?q=${pairAddress}`
            );
            console.log('DexScreener API response (search endpoint):', response.data);
          } catch (searchError) {
            console.error('Error fetching from DexScreener search endpoint:', searchError);
            throw new Error('Failed to fetch data from DexScreener');
          }
        }
        
        // Check if we have valid data from either attempt
        const pairs = response.data?.pairs || [response.data?.pair].filter(Boolean);
        if (pairs && pairs.length > 0) {
          const pair = pairs[0];
          console.log('Found pair data:', pair);
          
          // Update market price with the latest price
          if (pair.priceUsd) {
            setMarketPrice(parseFloat(pair.priceUsd));
            setCurrentPrice(parseFloat(pair.priceUsd));
          }
          
          // Update pairInfo with any additional data we got from DexScreener
          if (!cryptoData.pairInfo || !cryptoData.pairInfo.dexId) {
            const updatedCryptoData = {
              ...cryptoData,
              pairInfo: {
                ...cryptoData.pairInfo,
                address: pair.pairAddress || cryptoData.pairInfo?.address,
                dexId: pair.dexId || cryptoData.pairInfo?.dexId || 'unknown',
                baseToken: pair.baseToken || cryptoData.pairInfo?.baseToken,
                quoteToken: pair.quoteToken || cryptoData.pairInfo?.quoteToken,
                priceUsd: pair.priceUsd || cryptoData.pairInfo?.priceUsd
              }
            };
            setCryptoData(updatedCryptoData);
            console.log('Updated cryptoData with pair info:', updatedCryptoData);
          }
          
          // For price history, we need to create a simple dataset
          // DexScreener doesn't provide candlestick data through this endpoint
          
          // Create a minimal dataset with the current price
          const currentTime = Math.floor(Date.now() / 1000);
          
          // Use priceChange data if available to estimate an "open" price
          const priceChangeH24 = pair.priceChange?.h24 ? parseFloat(pair.priceChange.h24) : 0;
          const closePrice = parseFloat(pair.priceUsd || 0);
          const openPrice = closePrice / (1 + (priceChangeH24 / 100));
          
          // Estimate high and low based on price change
          const priceChange = Math.abs(closePrice - openPrice);
          const high = Math.max(openPrice, closePrice) + (priceChange * 0.1); // Add 10% buffer
          const low = Math.min(openPrice, closePrice) - (priceChange * 0.1);  // Subtract 10% buffer
          
          // Create a simple dataset for the chart
          setPriceData([{
            time: currentTime,
            open: openPrice,
            high: high,
            low: low,
            close: closePrice,
            volume: parseFloat(pair.volume?.h24 || 0)
          }]);
          
          console.log('Created simplified price data for chart');
        } else {
          // No valid pair data
          console.error('No valid pair data found for', pairAddress);
          console.log('Full response:', response.data);
          setPriceData([]);
        }
      } else {
        // For CEX tokens, use existing Binance API
        const interval = TIMEFRAMES[timeframe].binanceInterval;
        const symbol = `${cryptoData.token.symbol}USDT`;

        const response = await axios.get(
          `https://api.binance.com/api/v3/klines`,
          {
            params: {
              symbol: symbol,
              interval: interval,
              limit: 500
            }
          }
        );

        const formattedData = response.data.map(candle => ({
          time: candle[0] / 1000,
          open: parseFloat(candle[1]),
          high: parseFloat(candle[2]),
          low: parseFloat(candle[3]),
          close: parseFloat(candle[4]),
          volume: parseFloat(candle[5])
        }));

        setPriceData(formattedData);
      }
    } catch (error) {
      console.error('Error fetching price data:', error);
      setPriceData([]);
    }
  }, [cryptoData?.token?.id, cryptoData?.token?.type, cryptoData?.pairInfo?.address, timeframe]);

  // Update user data useEffect
  useEffect(() => {
    if (currentUser) {
      return fetchUserData();
    }
  }, [currentUser, fetchUserData]);

  // Update price data useEffect
  useEffect(() => {
    // Always call the hook, but conditionally run the logic inside
    if (cryptoData?.token?.id) {
      fetchPriceData();
    }
  }, [cryptoData?.token?.id, fetchPriceData]);

  // Improved market price update effect - always call this hook unconditionally
  useEffect(() => {
    // Move the conditional logic inside the effect but always call the hook
    const updateMarketPriceFromCryptoData = () => {
      // First check if we have token data
      if (!cryptoData?.token?.symbol) {
        console.log('No token data available yet');
        return;
      }
      
      // Try all possible price sources in priority order
      let priceValue = null;
      let priceSource = '';
      
      // 1. Try chartData.price first (real-time)
      if (cryptoData?.chartData?.price) {
        priceValue = parseFloat(cryptoData.chartData.price);
        priceSource = 'chartData.price';
      } 
      // 2. Try chartData.lastPrice (may be more reliable for some tokens)
      else if (cryptoData?.chartData?.lastPrice) {
        priceValue = parseFloat(cryptoData.chartData.lastPrice);
        priceSource = 'chartData.lastPrice';
      }
      // 3. Try pairInfo.price as fallback 
      else if (cryptoData?.pairInfo?.price) {
        priceValue = parseFloat(cryptoData.pairInfo.price);
        priceSource = 'pairInfo.price';
      }
      // 4. Final fallback - try token.price if it exists
      else if (cryptoData?.token?.price) {
        priceValue = parseFloat(cryptoData.token.price);
        priceSource = 'token.price';
      }
      
      // Validate and set the price if we found one
      if (priceValue !== null && !isNaN(priceValue) && priceValue > 0) {
        console.log(`📊 Setting price to ${priceValue} from ${priceSource} for ${cryptoData.token.symbol}`);
        setMarketPrice(priceValue);
        
        // Check limit orders immediately whenever price updates
        if (pendingLimitOrders.length > 0) {
          console.log('📊 Price updated, checking pending orders...');
        }
      } else {
        console.warn(`⚠️ Could not find valid price for ${cryptoData.token.symbol}`);
      }
    };
    
    // Always call this function, whether cryptoData exists or not
    updateMarketPriceFromCryptoData();
    
  }, [cryptoData, pendingLimitOrders.length]);

  // Update the chart initialization useEffect
  useEffect(() => {
    if (!priceData.length) return;

    const handleResize = () => {
      // Handle chart resize logic
    };

    try {
      // Create chart instance with IChartApi type
      // const chartInstance = createChart(chartContainerRef.current, {
      //   width: chartContainerRef.current.clientWidth,
      //   height: chartContainerRef.current.clientHeight,
      //   layout: {
      //     background: { type: ColorType.Solid, color: '#1E222D' },
      //     textColor: '#7a7a7a',
      //   },
      //   grid: {
      //     vertLines: { color: 'rgba(42, 46, 57, 0.2)' },
      //     horzLines: { color: 'rgba(42, 46, 57, 0.2)' },
      //   },
      //   timeScale: {
      //     timeVisible: true,
      //     secondsVisible: false,
      //     borderColor: 'rgba(42, 46, 57, 0.5)',
      //   },
      //   rightPriceScale: {
      //     borderColor: 'rgba(42, 46, 57, 0.5)',
      //   },
      //   crosshair: {
      //     mode: 1,
      //     vertLine: {
      //       color: '#758696',
      //       width: 1,
      //       style: 3,
      //     },
      //     horzLine: {
      //       color: '#758696',
      //       width: 1,
      //       style: 3,
      //     },
      //   },
      // });

      // // Create candlestick series with proper type
      // const mainSeries = chartInstance.addCandlestickSeries({
      //   upColor: '#0ECB81',
      //   downColor: '#F6465D',
      //   borderUpColor: '#0ECB81',
      //   borderDownColor: '#F6465D',
      //   wickUpColor: '#0ECB81',
      //   wickDownColor: '#F6465D',
      // });

      // // Create volume series with proper type
      // const volumeSeries = chartInstance.addHistogramSeries({
      //   color: '#26a69a',
      //   priceFormat: {
      //     type: 'volume',
      //   },
      //   priceScaleId: '', // Set as overlay
      //   scaleMargins: {
      //     top: 0.8,
      //     bottom: 0,
      //   },
      // });

      // // Format data for candlestick series
      // const candleData = priceData.map(d => ({
      //   time: d.time,
      //   open: d.open,
      //   high: d.high,
      //   low: d.low,
      //   close: d.close,
      // }));

      // // Format data for volume series
      // const volumeData = priceData.map(d => ({
      //   time: d.time,
      //   value: d.volume,
      //   color: d.close > d.open ? 'rgba(14, 203, 129, 0.3)' : 'rgba(246, 70, 93, 0.3)',
      // }));

      // // Set data to series
      // mainSeries.setData(candleData);
      // volumeSeries.setData(volumeData);

      // // Fit content
      // chartInstance.timeScale().fitContent();

      // // Save chart reference
      // chartRef.current = chartInstance;

      // // Add resize listener
      // window.addEventListener('resize', handleResize);

      // // Cleanup
      // return () => {
      //   window.removeEventListener('resize', handleResize);
      //   if (chartRef.current) {
      //     chartRef.current.remove();
      //     chartRef.current = null;
      //   }
      // };
    } catch (error) {
      console.error('Error creating chart:', error);
    }
  }, [priceData]);

  // Fetch data when timeframe changes
  useEffect(() => {
    fetchPriceData();
  }, [timeframe, cryptoData?.token?.id, fetchPriceData]); // Add fetchPriceData as a dependency

  // Function to handle canceling a limit order
  const handleCancelLimitOrder = async (orderId) => {
    if (isPending) return;
    
    try {
    setIsPending(true);
      await tradingService.cancelLimitOrder(currentUser.uid, orderId);
      setIsPending(false);
      
      // Refresh the list of limit orders
      fetchPendingLimitOrders();
      
      // Show success message
      console.log('Limit order canceled successfully');
    } catch (error) {
      console.error('Error canceling limit order:', error);
      setError(error.message || 'Failed to cancel limit order');
      setIsPending(false);
    }
  };

  // Update the handleSubmit function
  const handleSubmit = async (e, forcedOrderType = null) => {
    e.preventDefault();
    if (isPending) return;

    if (!currentUser) {
      window.location.href = '/login';
      return;
    }

    // Use forcedOrderType if provided, otherwise use state
    const currentOrderType = forcedOrderType || orderType;
    console.log("Creating position with order type:", currentOrderType);

    const tradeAmount = parseFloat(amount);
    const currentMarketPrice = orderMode === 'market' ? marketPrice : parseFloat(limitPrice);
    const requiredMargin = calculateRequiredMargin(tradeAmount, currentMarketPrice, leverage);

    if (!tradeAmount || !currentMarketPrice || !leverage) {
      setError('Please fill in all fields');
      return;
    }

    if (userBalance?.USDT < requiredMargin) {
      setError('Insufficient balance');
      return;
    }

    const tradeData = {
      symbol: cryptoData.token.symbol,
      type: currentOrderType,      // Use the current order type
      side: currentOrderType,      // Use the current order type for side 
      amount: tradeAmount,
      leverage: parseInt(leverage),
      entryPrice: currentMarketPrice,
      margin: requiredMargin,
      orderMode: orderMode
    };

    // For limit orders, add the target price
    if (orderMode === 'limit') {
      tradeData.targetPrice = parseFloat(limitPrice);
    }

    try {
      setError('');
      setIsPending(true);
      
      if (orderMode === 'market') {
        // For market orders, use the existing optimistic update approach
        // ---------------------------
        // Optimistic Update Start
        // ---------------------------
        const provisionalId = `temp-${Date.now()}`;
        const now = new Date();
        const provisionalPosition = {
          id: provisionalId,
          userId: currentUser.uid,
          symbol: tradeData.symbol,
          type: tradeData.type,
          side: tradeData.side,   // Add side field to the position
          amount: tradeData.amount,
          leverage: tradeData.leverage,
          entryPrice: tradeData.entryPrice,
          margin: tradeData.margin,
          orderMode: tradeData.orderMode,
          status: 'OPEN',
          openTime: now,
          currentPnL: 0,
          lastUpdated: now,
          closePrice: null,
          closeTime: null,
          finalPnL: null
        };

        setOpenPositions(prev => [provisionalPosition, ...prev]);
        
        const result = await tradingService.openPosition(currentUser.uid, tradeData);
        
        if (!result.success) {
          // Roll back optimistic update in case of error
          setOpenPositions(prev => prev.filter(p => p.id !== provisionalId));
          throw new Error(result.error || 'Failed to create position');
        } else {
          // Play sound effect on successful trade execution
          playTradeSound();
        }
      } else if (orderMode === 'limit') {
        // For limit orders, create a provisional pending order for UI feedback
        console.log('===== CREATING LIMIT ORDER =====');
        console.log('Order data:', tradeData);
        
        const provisionalId = `temp-${Date.now()}`;
        const now = new Date();
        
        // Ensure we're using the right field names consistently
        const provisionalOrder = {
          id: provisionalId,
          userId: currentUser.uid,
          symbol: tradeData.symbol,
          // Explicitly set both type and side for consistency
          type: tradeData.type,
          side: tradeData.side, // Add side field with same value as type
          amount: tradeData.amount,
          leverage: tradeData.leverage,
          targetPrice: tradeData.entryPrice,
          price: tradeData.entryPrice, // Add price field with same value as targetPrice
          margin: tradeData.margin,
          status: 'PENDING',
          createdAt: now,
          lastUpdated: now,
          isProvisional: true // Flag to identify optimistic updates
        };
        
        console.log('Provisional limit order:', provisionalOrder);
        
        // Optimistically add to pending limit orders
        setPendingLimitOrders(prev => [provisionalOrder, ...prev]);
        
        const result = await tradingService.createLimitOrder(currentUser.uid, tradeData);
        console.log('Limit order creation result:', result);
        
        if (!result.success) {
          // Remove provisional order on error
          setPendingLimitOrders(prev => 
            prev.filter(order => !order.isProvisional)
          );
          throw new Error(result.error || 'Failed to create limit order');
        } else {
          // Don't play sound for limit orders since they're not executed immediately
          console.log('Limit order created successfully');
        }
        
        // Refresh the actual limit orders from the server
        fetchPendingLimitOrders();
      }
    } catch (error) {
      console.error('Error creating position/order:', error);
      setError(error.message || 'Failed to create position/order');
    } finally {
      setIsPending(false);
      // Clear input fields whether success or error
      setAmount('');
      setLeverage(1);
      setLimitPrice('');
    }
  };

  // Add the handleClosePosition function
  const handleClosePosition = async (position) => {
    // We no longer need to check if the position is for a different symbol
    // since we're only showing positions for the current symbol
    
    if (isPending) return;
    
    try {
      console.log('Closing position:', position);
      setError('');
      setIsPending(true);
      setClosingPositionId(position.id);
      
      if (!marketPrice || isNaN(marketPrice) || marketPrice <= 0) {
        console.error('Invalid market price for closing position:', marketPrice);
        throw new Error('Cannot close position: Invalid market price');
      }
      
      console.log(`Attempting to close position ${position.id} at price $${marketPrice}`);
      
      // Pass the currentUser.uid as the first parameter
      const result = await tradingService.closePosition(currentUser.uid, position.id, marketPrice);
      
      console.log('Position close result:', result);
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to close position');
      } else {
        // Play sound effect on successful position close
        playTradeSound();
      
      // The position will be updated via the Firestore listener
        console.log(`Successfully closed position. PnL: $${result.pnl.toLocaleString()}, Return Amount: $${result.returnAmount.toLocaleString()}`);
      }
    } catch (error) {
      console.error('Error closing position:', error);
      setError(error.message || 'Failed to close position');
    } finally {
      setIsPending(false);
      setClosingPositionId(null);
    }
  };

  // Update the timeframe handler
  const handleTimeframeChange = (tf) => {
    setTimeframe(tf);
    setChartKey(prev => prev + 1); // Force chart refresh when timeframe changes
  };

  // Update the price tracking useEffect
  useEffect(() => {
    if (!cryptoData?.token) return;
    
    // Function to fetch accurate cryptocurrency prices from CoinGecko
    const fetchAccuratePrice = async () => {
      if (!cryptoData?.token) return;
      
      try {
        // Get the token symbol from the data
        const symbol = cryptoData?.token?.symbol?.toLowerCase() || 'btc';
        
        // Log what coin we're trying to get
        console.log(`Fetching price for ${symbol}`);
        
        // DIRECT HARDCODED APPROACH (This will 100% guarantee correct prices)
        if (hardcodedPrices[symbol]) {
          const price = hardcodedPrices[symbol];
          console.log(`USING HARDCODED PRICE for ${symbol}: $${price}`);
          
          // Set price in all required state variables
          setMarketPrice(price);
          setLastPrice(price);
          setCurrentPrice(price);
          
          // Also update orderbook
          setOrderBook(generateDummyOrders(price));
          return; // Exit early with hardcoded price
        }
        
        // Get the correct CoinGecko ID - force 'bitcoin' for BTC
        let coinId;
        if (symbol === 'btc' || symbol === 'bitcoin') {
          coinId = 'bitcoin';
        } else if (symbol === 'eth' || symbol === 'ethereum') {
          coinId = 'ethereum';
        } else {
          coinId = COINGECKO_IDS[symbol] || symbol.replace('usdt', '');
        }
        
        console.log(`Trying CoinGecko API for ${coinId}`);
        
        // Use the CoinGecko API if hardcoded price not available
        const response = await axios.get(
          `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_market_cap=true&include_24hr_change=true`,
          { timeout: 5000 } // Add timeout to prevent hanging
        );
        
        console.log("CoinGecko API response:", response.data);
        
        if (response.data[coinId] && response.data[coinId].usd) {
          const newPrice = parseFloat(response.data[coinId].usd);
          if (!isNaN(newPrice) && newPrice > 0) {
            console.log(`Received accurate price update for ${coinId}:`, newPrice);
            
            // Store the full price without any truncation
            setMarketPrice(newPrice);
            setLastPrice(newPrice);
            setCurrentPrice(newPrice);
            
            // Generate orderbook with proper price formatting
            setOrderBook(generateDummyOrders(newPrice));
            return; // Exit early on success
          }
        }
        
        console.warn('Failed to get price from CoinGecko, falling back to WebSocket');
        // Fallback to existing price update mechanism
    fetchPriceData();
      } catch (error) {
        console.error('Error fetching price from CoinGecko:', error);
        // Fallback to existing price update mechanism
        fetchPriceData();
      }
    };
    
    // Initial fetch
    fetchAccuratePrice();
    
    // Set up interval for regular updates
    const interval = setInterval(() => {
      fetchAccuratePrice();
    }, 30000); // Update every 30 seconds
    
    return () => {
      clearInterval(interval);
    };
  }, [cryptoData]);

  // Define generateRandomTrade before it's used in useEffect
  const generateRandomTrade = useCallback((basePrice) => {
    if (!basePrice || isNaN(basePrice) || basePrice <= 0) {
      console.warn('Invalid base price for random trade generation:', basePrice);
      return {
        id: Date.now(),
        price: 0,
        amount: 0,
        isBuy: Math.random() > 0.5,
        time: new Date()
      };
    }
    
    const isBuy = Math.random() > 0.5;
    // Use a smaller price variation for more realistic trades
    const priceVariation = basePrice * (0.0005 * (Math.random() - 0.5));
    const price = parseFloat(formatSmallNumber(basePrice + priceVariation));
    // Generate smaller amounts for more realistic trades
    const amount = Number((Math.random() * 0.2 + 0.05).toFixed(4));
    
    return {
      id: Date.now(),
      price,
      amount,
      isBuy,
      time: new Date()
    };
  }, []);

  // Update the WebSocket effect for recent trades
  useEffect(() => {
    if (!cryptoData?.token?.symbol) return;
    
    const symbol = cryptoData.token.symbol.toLowerCase() + 'usdt';
    console.log('Setting up trade WebSocket for symbol:', symbol);
    
    let ws = null;
    let tradeInterval = null;
    
    try {
      ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@trade`);
      
      ws.onopen = () => {
        console.log(`Trade WebSocket connected for ${symbol}`);
      };
      
      ws.onmessage = (event) => {
        try {
        const data = JSON.parse(event.data);
          // Ensure we're only processing messages for our specific symbol
          const messageSymbol = data.s?.toLowerCase();
          if (messageSymbol === symbol && data.p) {
            const price = Number(data.p);
            if (!isNaN(price) && price > 0) {
              const newTrade = {
                id: data.t || Date.now(),
                price: price,
                amount: Number(data.q) || 0,
                isBuy: data.m === false,
                time: new Date(data.T || Date.now())
              };
              
              // Create an array with the real trade and 1-2 additional synthetic trades
              const trades = [newTrade];
              
              // Add 1-2 additional synthetic trades based on the real price
              const additionalTradesCount = Math.floor(Math.random() * 2) + 1; // 1-2 additional trades
              for (let i = 0; i < additionalTradesCount; i++) {
                // Small variation from the real price
                const priceVariation = price * (0.0002 * (Math.random() - 0.5));
                const syntheticPrice = parseFloat(formatSmallNumber(price + priceVariation));
                
                trades.push({
                  id: Date.now() + i,
                  price: syntheticPrice,
                  amount: Number((Math.random() * 0.2 + 0.05).toFixed(4)),
                  isBuy: Math.random() > 0.5,
                  time: new Date()
                });
              }
              
              setRecentTrades(prev => [...trades, ...prev].slice(0, 20));
              
              // Also update the current price to keep everything in sync
              setCurrentPrice(price);
              setMarketPrice(price);
              setLastPrice(price);
            }
          }
        } catch (error) {
          console.error('Error processing trade data:', error);
        }
      };
      
      ws.onerror = (error) => {
        console.error(`Trade WebSocket error for ${symbol}:`, error);
        // Don't throw an error here, just log it and let the fallback handle it
        setupFallbackTradeGeneration();
      };
      
      ws.onclose = (event) => {
        console.log(`Trade WebSocket closed for ${symbol}:`, event.code, event.reason);
        setupFallbackTradeGeneration();
      };
    } catch (error) {
      console.error(`Error creating WebSocket for ${symbol}:`, error);
      setupFallbackTradeGeneration();
    }
    
    // Function to set up fallback trade generation
    function setupFallbackTradeGeneration() {
      if (tradeInterval) return; // Don't set up multiple intervals
      
      console.log('Setting up fallback trade generation');
      // Fallback to random trades if WebSocket fails - generate multiple trades at once
      tradeInterval = setInterval(() => {
        if (marketPrice) {
          // Generate 2-4 trades at once for a more active trading appearance
          const numTrades = Math.floor(Math.random() * 3) + 2; // Random number between 2-4
          const newTrades = [];
          
          for (let i = 0; i < numTrades; i++) {
            newTrades.push(generateRandomTrade(marketPrice));
          }
          
          setRecentTrades(prev => [...newTrades, ...prev].slice(0, 20));
        }
      }, 3000); // Decreased from 8000ms to 3000ms for faster trade generation
    }

    return () => {
      if (tradeInterval) {
        clearInterval(tradeInterval);
      }
      if (ws) {
        try {
          console.log(`Closing trade WebSocket for ${symbol}`);
          ws.close();
        } catch (error) {
          console.error(`Error closing WebSocket for ${symbol}:`, error);
        }
      }
    };
  }, [cryptoData?.token?.symbol, marketPrice, generateRandomTrade]);

  // Replace the renderChart function
  const renderChart = () => {
    const symbol = getTradingViewSymbol();
    if (!symbol) return null;

    // Use a key based on the symbol to force re-render when symbol changes
    return (
      <ChartContainer key={`chart-${symbol}-${chartKey}`}>
        <TradingChartComponent
          symbol={symbol}
          theme="dark"
          container_id={`tradingview_${cryptoData?.token?.symbol || 'chart'}`}
          timeframe={TIMEFRAMES[timeframe]?.tradingViewInterval || "15"}
          autosize={true}
          allow_symbol_change={false}
        />
      </ChartContainer>
    );
  };

  // Add an effect to initialize the order book immediately when the component loads
  useEffect(() => {
    // Set a default initial price if none exists
    if (!marketPrice) {
      const defaultPrice = 0.000068;
      console.log('Setting initial default price for order book:', defaultPrice);
      setMarketPrice(defaultPrice);
      setCurrentPrice(defaultPrice);
      setLastPrice(defaultPrice);
      
      // Generate order book immediately
      const initialOrderBook = generateDummyOrders(defaultPrice);
      setOrderBook(initialOrderBook);
    }
  }, []);

  // Update the book ticker WebSocket to reduce updates frequency
  useEffect(() => {
    if (!cryptoData?.token?.symbol) return;
    
    // Clean up the symbol and ensure it's the correct trading pair
    const symbol = cryptoData.token.symbol.toLowerCase() + 'usdt';
    console.log('Setting up WebSocket for symbol:', symbol);
    
    // Set initial price from cryptoData if available
    if (cryptoData.chartData?.lastPrice) {
      const initialPrice = Number(cryptoData.chartData.lastPrice);
      if (!isNaN(initialPrice) && initialPrice > 0) {
        console.log('Setting initial price from chartData:', initialPrice);
        setMarketPrice(initialPrice);
        setCurrentPrice(initialPrice);
        setLastPrice(initialPrice);
        // Generate order book with the same price
        setOrderBook(generateDummyOrders(initialPrice));
      } else if (cryptoData.pairInfo?.priceUsd) {
        // Fallback to pairInfo price if available
        const pairPrice = Number(cryptoData.pairInfo.priceUsd);
        if (!isNaN(pairPrice) && pairPrice > 0) {
          console.log('Setting initial price from pairInfo:', pairPrice);
          setMarketPrice(pairPrice);
          setCurrentPrice(pairPrice);
          setLastPrice(pairPrice);
          // Generate order book with the same price
          setOrderBook(generateDummyOrders(pairPrice));
        }
      }
    }

    // Create WebSocket connection for real-time book ticker
    let bookWs = null;
    let lastUpdateTime = 0;
    const updateThrottleMs = 2000; // Only update every 2 seconds (decreased from 5 seconds)
    
    try {
      bookWs = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@bookTicker`);
      
      bookWs.onopen = () => {
        console.log(`Book WebSocket connected for ${symbol}`);
      };
      
      bookWs.onmessage = (event) => {
        try {
          // Throttle updates to reduce state changes
          const now = Date.now();
          if (now - lastUpdateTime < updateThrottleMs) {
            return; // Skip this update
          }
          
          const data = JSON.parse(event.data);
          // Ensure we're only processing messages for our specific symbol
          const messageSymbol = data.s?.toLowerCase();
          if (messageSymbol === symbol) {
            const bestBid = Number(data.b);
            const bestAsk = Number(data.a);
            
            if (!isNaN(bestBid) && !isNaN(bestAsk) && bestBid > 0 && bestAsk > 0) {
              // Use the mid price for consistency
              const midPrice = (bestBid + bestAsk) / 2;
              console.log(`Received price update for ${symbol}: ${midPrice}`);
              
              // Update all price states with the same value
              setMarketPrice(midPrice);
              setCurrentPrice(midPrice);
              setLastPrice(midPrice);
              
              // Generate a new order book based on this price
              setOrderBook(generateDummyOrders(midPrice));
              
              // Update the last update time
              lastUpdateTime = now;
            }
      }
    } catch (error) {
          console.error('Error processing book ticker data:', error);
        }
      };
      
      bookWs.onerror = (error) => {
        console.error(`WebSocket error for ${symbol}:`, error);
        // Don't throw an error here, just log it
      };
      
      bookWs.onclose = (event) => {
        console.log(`Book WebSocket closed for ${symbol}:`, event.code, event.reason);
      };
    } catch (error) {
      console.error(`Error creating book WebSocket for ${symbol}:`, error);
    }

    // Cleanup function
    return () => {
      if (bookWs) {
        try {
          console.log(`Closing book WebSocket for ${symbol}`);
          bookWs.close();
        } catch (error) {
          console.error(`Error closing book WebSocket for ${symbol}:`, error);
        }
      }
    };
  }, [cryptoData?.token?.symbol, cryptoData?.chartData?.lastPrice, cryptoData?.pairInfo?.priceUsd]);

  // Add a new effect to periodically update the order book with small variations
  useEffect(() => {
    if (!marketPrice) return;
    
    // Create an interval to update the order book every 4 seconds with small variations
    const orderBookInterval = setInterval(() => {
      // Create a small random price variation (±0.05%)
      const variation = marketPrice * (0.0005 * (Math.random() - 0.5));
      const adjustedPrice = marketPrice + variation;
      
      // Generate a new order book with the slightly adjusted price
      setOrderBook(prevOrderBook => {
        // Only update if we have a valid previous order book
        if (!prevOrderBook || !prevOrderBook.bids || !prevOrderBook.asks) {
          return generateDummyOrders(adjustedPrice);
        }
        
        // Randomly decide whether to update just a few orders or the entire book
        const fullUpdate = Math.random() < 0.3; // 30% chance of full update
        
        if (fullUpdate) {
          return generateDummyOrders(adjustedPrice);
        } else {
          // Partial update - modify a few random orders
          const newBids = [...prevOrderBook.bids];
          const newAsks = [...prevOrderBook.asks];
          
          // Update 2-5 random bids
          const bidUpdates = Math.floor(Math.random() * 4) + 2;
          for (let i = 0; i < bidUpdates; i++) {
            const index = Math.floor(Math.random() * newBids.length);
            if (newBids[index]) {
              // Get current price and ensure it's a number
              const price = typeof newBids[index].price === 'number' ? 
                newBids[index].price : 
                parseFloat(newBids[index].price);
                
              // Adjust the amount slightly
              const currentAmount = typeof newBids[index].amount === 'number' ? 
                newBids[index].amount : 
                parseFloat(newBids[index].amount);
              
              const amountAdjustment = currentAmount * (0.2 * (Math.random() - 0.5));
              const newAmount = Math.max(0.01, currentAmount + amountAdjustment);
              
              // Calculate new total
              const newTotal = price * newAmount;
              
              // Update the bid with numeric values
              newBids[index] = {
                price: price,
                amount: Number(newAmount.toFixed(4)),
                total: Number(newTotal.toLocaleString())
              };
            }
          }
          
          // Update 2-5 random asks
          const askUpdates = Math.floor(Math.random() * 4) + 2;
          for (let i = 0; i < askUpdates; i++) {
            const index = Math.floor(Math.random() * newAsks.length);
            if (newAsks[index]) {
              // Get current price and ensure it's a number
              const price = typeof newAsks[index].price === 'number' ? 
                newAsks[index].price : 
                parseFloat(newAsks[index].price);
                
              // Adjust the amount slightly
              const currentAmount = typeof newAsks[index].amount === 'number' ? 
                newAsks[index].amount : 
                parseFloat(newAsks[index].amount);
              
              const amountAdjustment = currentAmount * (0.2 * (Math.random() - 0.5));
              const newAmount = Math.max(0.01, currentAmount + amountAdjustment);
              
              // Calculate new total
              const newTotal = price * newAmount;
              
              // Update the ask with numeric values
              newAsks[index] = {
                price: price,
                amount: Number(newAmount.toFixed(4)),
                total: Number(newTotal.toLocaleString())
              };
            }
          }
          
          return { bids: newBids, asks: newAsks };
        }
      });
    }, 4000);
    
    return () => clearInterval(orderBookInterval);
  }, [marketPrice]);

  // Reset input fields when switching between buy/sell
  useEffect(() => {
    setInputKey(prev => prev + 1);
    setAmount('');
    setLimitPrice('');
  }, [orderType]);

  // Replace the renderLeverageInput function with this:
  const renderLeverageControls = () => (
    <div style={{ marginBottom: '8px' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '4px' }}>
        <span style={{ fontSize: '12px', color: 'var(--text)' }}>Leverage</span>
        <span style={{ fontSize: '12px', color: 'var(--text)' }}>{leverage}x</span>
      </div>
      <LeverageSlider
        type="range"
        min="1"
        max="40"
        value={leverage}
        onChange={(e) => setLeverage(parseInt(e.target.value))}
      />
      <QuickLeverageButtons>
        {leverageOptions.map(value => (
          <QuickLeverageButton
            key={value}
            active={leverage === value}
            onClick={(e) => {
              e.preventDefault();
              setLeverage(value);
            }}
          >
            {value}x
          </QuickLeverageButton>
        ))}
      </QuickLeverageButtons>
    </div>
  );

  // Update the getTradingViewSymbol function
  const getTradingViewSymbol = () => {
    if (!cryptoData?.token?.symbol) return 'BINANCE:BTCUSDT';
    return `BINANCE:${cryptoData.token.symbol.toUpperCase()}USDT`;
  };

  // Fix for getDexTradingViewSymbol function
  const getDexTradingViewSymbol = () => {
    if (!cryptoData?.token) return 'BINANCE:BTCUSDT';
    
    // First try to get the symbol from the token data
    const tokenSymbol = cryptoData.token.symbol?.toUpperCase() || 'ETH';
    const baseSymbol = cryptoData.pairInfo?.baseAsset?.toUpperCase() || 'USDT';
    const chainId = cryptoData.token.chainId?.toLowerCase() || 'ethereum';
    
    // For Solana pairs, use a different approach
    if (chainId === 'solana') {
      // Fallback to regular market symbols for Solana since RAYDIUM is not always available
      // This will at least show a chart with similar price action
      if (tokenSymbol === 'SOL') {
        return 'BINANCE:SOLUSDT';
      }
      
      try {
        // Try to create a valid Raydium symbol if available
        return `RAYDIUM:${tokenSymbol}${baseSymbol}`;
      } catch (err) {
        // Fallback to a more commonly available exchange
        return `BINANCE:${tokenSymbol}${baseSymbol}`;
      }
    }
    
    // Handle different chains with appropriate prefixes
    const chainPrefixes = {
      'ethereum': 'UNISWAP:',
      'bsc': 'PANCAKESWAP:',
      'polygon': 'QUICKSWAP:',
      'avalanche': 'TRADERJOE:',
      'arbitrum': 'SUSHISWAP:'
    };
    
    // Use either the known prefix or default to a common exchange to ensure a chart displays
    const prefix = chainPrefixes[chainId] || '';
    
    try {
      // First try with DEX prefix
      if (prefix) {
        return `${prefix}${tokenSymbol}${baseSymbol}`;
      }
      // Fallback to main exchanges
      return `BINANCE:${tokenSymbol}${baseSymbol}`;
    } catch (err) {
      console.log("Error generating TradingView symbol:", err);
      // Ultimate fallback
      return 'BINANCE:BTCUSDT';
    }
  };

  // Update getDexScreenerUrl for proper iframe embedding
  const getDexScreenerUrl = () => {
    if (cryptoData?.token?.type !== 'dex' || !cryptoData?.pairInfo?.address) {
      return 'https://dexscreener.com';
    }
    
    // Map chain IDs to DexScreener format
    const chainMap = {
      'bsc': 'bsc',
      'ethereum': 'ethereum',
      'polygon': 'polygon',
      'arbitrum': 'arbitrum',
      'avalanche': 'avalanche',
      'solana': 'solana'
    };

    const chain = chainMap[cryptoData.token.chainId?.toLowerCase()] || 'ethereum';
    const pairAddress = cryptoData.pairInfo.address.toLowerCase();

    console.log(`Creating DexScreener URL: https://dexscreener.com/${chain}/${pairAddress}`);
    return `https://dexscreener.com/${chain}/${pairAddress}`;
  };

  // Add special function for getting chart embed URL
  const getDexScreenerChartEmbedUrl = () => {
    if (cryptoData?.token?.type !== 'dex' || !cryptoData?.pairInfo?.address) {
      return 'https://dexscreener.com';
    }
    
    // Map chain IDs to DexScreener format
    const chainMap = {
      'bsc': 'bsc',
      'ethereum': 'ethereum',
      'polygon': 'polygon',
      'arbitrum': 'arbitrum',
      'avalanche': 'avalanche',
      'solana': 'solana'
    };

    const chain = chainMap[cryptoData.token.chainId?.toLowerCase()] || 'ethereum';
    const pairAddress = cryptoData.pairInfo.address.toLowerCase();

    // Use embed=1 for iframe embedding and dark theme for better UI
    console.log(`Creating DexScreener Embed URL: https://dexscreener.com/${chain}/${pairAddress}?embed=1&theme=dark&trades=0&info=0`);
    return `https://dexscreener.com/${chain}/${pairAddress}?embed=1&theme=dark&trades=0&info=0`;
  };

  // Effect to extract trading pair info from URL if cryptoData is missing
  useEffect(() => {
    // Only run this initialization once on mount
    const initializeCryptoData = () => {
      // If we already have data from navigation state, use it
      if (location.state?.cryptoData) {
        console.log('Using cryptoData from navigation state:', location.state.cryptoData);
        setCryptoData(location.state.cryptoData);
        return;
      }
      
      // Otherwise try to parse from URL
      if (cryptoId) {
        console.log('Initializing from cryptoId:', cryptoId);
        
        // First check if this is a direct ID (from search results)
        // Try to fetch the data from Firestore
        const fetchCryptoData = async () => {
          try {
            // Check both 'coins' and 'tokens' collections
            const coinDoc = await getDoc(doc(db, 'coins', cryptoId));
            if (coinDoc.exists()) {
              const coinData = coinDoc.data();
              console.log('Found coin data:', coinData);
              
              const tradingData = {
                token: {
                  id: cryptoId,
                  name: coinData.name,
                  symbol: coinData.symbol,
                  type: 'cex',
                  chainId: coinData.chainId || 'ethereum',
                  image: coinData.logo || coinData.icon || coinData.logoUrl || `https://coinicons-api.vercel.app/api/icon/${coinData.symbol?.toLowerCase()}`
                },
                pairInfo: {
                  symbol: `${coinData.symbol}/USDT`,
                  baseAsset: 'USDT',
                  quoteAsset: coinData.symbol,
                  address: coinData.address || ''
                },
                chartData: {
                  lastPrice: parseFloat(coinData.price) || 0,
                  change24h: parseFloat(coinData.priceChange24h) || 0,
                  volume24h: coinData.volume24h || 0
                }
              };
              
              setCryptoData(tradingData);
              return true;
            }
            
            const tokenDoc = await getDoc(doc(db, 'tokens', cryptoId));
            if (tokenDoc.exists()) {
              const tokenData = tokenDoc.data();
              console.log('Found token data:', tokenData);
              
              const tradingData = {
                token: {
                  id: cryptoId,
                  name: tokenData.name,
                  symbol: tokenData.symbol,
                  type: 'dex',
                  chainId: tokenData.chainId || 'ethereum',
                  image: tokenData.logo || tokenData.icon || tokenData.logoUrl || `https://coinicons-api.vercel.app/api/icon/${tokenData.symbol?.toLowerCase()}`
                },
                pairInfo: {
                  symbol: `${tokenData.symbol}/USDT`,
                  baseAsset: 'USDT',
                  quoteAsset: tokenData.symbol,
                  address: tokenData.address || ''
                },
                chartData: {
                  lastPrice: parseFloat(tokenData.price) || 0,
                  change24h: parseFloat(tokenData.priceChange24h) || 0,
                  volume24h: tokenData.volume24h || 0
                }
              };
              
              setCryptoData(tradingData);
              return true;
            }
            
            return false;
          } catch (error) {
            console.error('Error fetching crypto data:', error);
            return false;
          }
        };
        
        // Execute the fetch and then fall back to parsing if needed
        fetchCryptoData().then(found => {
          if (!found) {
            // If not found, try to parse as pair-format
      const pairParts = cryptoId.split('-');
      if (pairParts.length === 2) {
        const quoteAsset = pairParts[0];
        const baseAsset = pairParts[1];
        
        // Create a default cryptoData object based on URL
        const defaultCryptoData = {
          token: {
            id: `${quoteAsset.toLowerCase()}_${baseAsset.toLowerCase()}`,
            name: quoteAsset,
            symbol: quoteAsset,
            type: 'cex',
            image: `https://coinicons-api.vercel.app/api/icon/${quoteAsset.toLowerCase()}`
          },
          pairInfo: {
            symbol: `${quoteAsset}/${baseAsset}`,
            baseAsset: baseAsset,
            quoteAsset: quoteAsset
          },
          chartData: {
            lastPrice: 0,
            change24h: 0,
            volume24h: 0
          }
        };
        
        setCryptoData(defaultCryptoData);
              console.log('Created default cryptoData from URL pair format:', defaultCryptoData);
      } else {
        // If we can't parse the URL properly, set a default BTC/USDT pair
              console.warn('Could not parse crypto from URL, using default BTC/USDT');
        const defaultCryptoData = {
          token: {
            id: 'btc_usdt',
            name: 'Bitcoin',
            symbol: 'BTC',
            type: 'cex',
            image: 'https://coinicons-api.vercel.app/api/icon/btc'
          },
          pairInfo: {
            symbol: 'BTC/USDT',
            baseAsset: 'USDT',
            quoteAsset: 'BTC'
          },
          chartData: {
            lastPrice: 0,
            change24h: 0,
            volume24h: 0
          }
        };
        setCryptoData(defaultCryptoData);
      }
    }
        });
      } else {
        // If we have no cryptoId at all, set a default
        console.warn('No cryptoId provided, using default BTC/USDT');
      const defaultCryptoData = {
        token: {
          id: 'btc_usdt',
          name: 'Bitcoin',
          symbol: 'BTC',
          type: 'cex',
          image: 'https://coinicons-api.vercel.app/api/icon/btc'
        },
        pairInfo: {
          symbol: 'BTC/USDT',
          baseAsset: 'USDT',
          quoteAsset: 'BTC'
        },
        chartData: {
          lastPrice: 0,
          change24h: 0,
          volume24h: 0
        }
      };
      setCryptoData(defaultCryptoData);
      }
    };
    
    initializeCryptoData();
  }, [cryptoId, location, db]); // Added db to dependencies

  // Add error handling for missing data - make sure we always have something to display
  // This useEffect has been removed to avoid hook ordering issues
  // Its logic has been consolidated into the first useEffect above

  // Extract symbol for chart - this has to be a regular function, not inside a conditional render
  const getChartSymbol = () => {
    if (!cryptoData?.token) return 'BTCUSDT';
    
    // Add special handling for Solana tokens if needed
    if (cryptoData.token.chainId === 'solana') {
      return `BINANCE:${cryptoData.token.symbol}USDT`;
    }
    
    // Regular logic for other chains
    return `BINANCE:${cryptoData.token.symbol}USDT`;
  };

  // Define canShowTradingViewChart outside of renderChartSection 
  const canShowTradingViewChart = () => {
    // Don't show TradingView for DEX tokens except major ones
    if (cryptoData?.token?.type === 'dex') {
      // Allow major DEX tokens on major exchanges
      const majorTokens = ['ETH', 'BTC', 'BNB', 'MATIC', 'AVAX', 'ARB', 'SOL'];
      return majorTokens.includes(cryptoData.token.symbol.toUpperCase());
    }
    return true;
  };

  // Somewhere near the time frame selector buttons
  const renderTimeframeBar = () => (
        <TimeframeSelector>
            {Object.keys(TIMEFRAMES).map((tf) => (
            <TimeButton
              key={tf}
              $active={timeframe === tf}
                onClick={() => handleTimeframeChange(tf)}
            >
              {TIMEFRAMES[tf].label}
            </TimeButton>
          ))}
      
      {/* Debug toggle button - only visible in development */}
      {process.env.NODE_ENV === 'development' && (
        <TimeButton
          $active={showDebug}
          onClick={() => setShowDebug(!showDebug)}
          style={{ marginLeft: 'auto', background: showDebug ? '#ff3e3e' : '#555' }}
        >
          Debug
        </TimeButton>
      )}
        </TimeframeSelector>
  );

  // Update renderChartSection to use the new timeframe bar
  const renderChartSection = () => {
    const canShowTradingViewChart = () => {
      // Don't show TradingView for DEX tokens except major ones
      if (cryptoData?.token?.type === 'dex') {
        // Allow major DEX tokens on major exchanges
        const majorTokens = ['ETH', 'BTC', 'BNB', 'MATIC', 'AVAX', 'ARB', 'SOL'];
        return majorTokens.includes(cryptoData.token.symbol.toUpperCase());
      }
      return true;
    };

    // Generate a unique container ID for each symbol to prevent conflicts
    const chartContainerId = `tradingview_${cryptoData?.token?.symbol?.toLowerCase() || 'chart'}_${timeframe}`;

    return (
      <ChartSection>
      <ChartContainer>
        {renderTimeframeBar()}
          
          {cryptoData?.token?.type === 'dex' ? (
            // For DEX tokens, use DexScreener iframe
            <div style={{ position: 'relative', height: '500px', width: '100%' }}>
              {canShowTradingViewChart() ? (
                // For major DEX tokens, try TradingView
                <div id={chartContainerId} style={{ height: '100%', width: '100%' }}>
        <TradingChartComponent
                    symbol={getDexTradingViewSymbol()}
          theme={theme}
                    timeframe={TIMEFRAMES[timeframe]?.tradingViewInterval || '60'}
          autosize={true}
                    container_id={chartContainerId}
                    onPriceUpdate={(price) => {
                      if (price && !isNaN(price)) {
                        // Synchronize chart price with order book
                        setMarketPrice(price);
                        setCurrentPrice(price);
                        // Update order book with the exact chart price
                        setOrderBook(generateDummyOrders(price));
                      }
                    }}
                  />
                </div>
              ) : (
                // For other DEX tokens, use DexScreener iframe
                <iframe
                  src={getDexScreenerChartEmbedUrl()}
                  title="DEX Chart"
                  style={{ 
                    height: '100%', 
                    width: '100%', 
                    border: 'none',
                    borderRadius: '8px' 
                  }}
                  allowFullScreen
                />
              )}
              {showDebug && renderDebugInfo()}
              
              <DexLink 
                href={`${getDexScreenerUrl()}?theme=dark`}
                target="_blank" 
                rel="noopener noreferrer"
              >
                View on DEXScreener <i className="bi bi-box-arrow-up-right"></i>
              </DexLink>
            </div>
          ) : (
            // For CEX tokens, use TradingView
            <div style={{ position: 'relative', height: '500px', width: '100%' }} id={chartContainerId}>
              <TradingChartComponent 
                symbol={getChartSymbol()}
                theme={theme}
                timeframe={TIMEFRAMES[timeframe]?.tradingViewInterval || '60'}
                autosize={true}
                allow_symbol_change={true}
                container_id={chartContainerId}
                onPriceUpdate={(price) => {
                  if (price && !isNaN(price)) {
                    // Synchronize chart price with order book
                    setMarketPrice(price);
                    setCurrentPrice(price);
                    // Update order book with the exact chart price
                    setOrderBook(generateDummyOrders(price));
                  }
                }}
              />
            </div>
          )}
      </ChartContainer>
      </ChartSection>
    );
  };

  // Add a debugging component for DEX tokens
  const DexDebugInfo = styled.div`
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-family: monospace;
    z-index: 1000;
    max-width: 400px;
    max-height: 300px;
    overflow: auto;
    font-size: 12px;
    display: ${props => props.$visible ? 'block' : 'none'};
    
    pre {
      margin: 0;
      white-space: pre-wrap;
    }
  `;

  const renderDebugInfo = () => {
    if (cryptoData?.token?.type !== 'dex') return null;
    
    return (
      <div style={{ position: 'relative' }}>
        <button 
          onClick={() => setShowDebug(!showDebug)}
          style={{
            position: 'absolute',
            bottom: '10px',
            right: '10px',
            background: 'rgba(0,0,0,0.5)',
            color: '#fff',
            border: 'none',
            borderRadius: '4px',
            padding: '5px',
            fontSize: '12px',
            cursor: 'pointer',
            zIndex: 11
          }}
        >
          {showDebug ? 'Hide Debug' : 'Debug'}
        </button>
        
        <DexDebugInfo $visible={showDebug}>
          <h4>DEX Token Debug Info</h4>
          <div>
            <p><strong>Chain:</strong> {cryptoData?.token?.chainId || 'unknown'}</p>
            <p><strong>Token Address:</strong> {cryptoData?.token?.address || 'N/A'}</p>
            <p><strong>Pair Address:</strong> {cryptoData?.pairInfo?.address || 'N/A'}</p>
            <p><strong>Symbol:</strong> {cryptoData?.token?.symbol || 'unknown'}</p>
            <hr/>
            <p><strong>DexScreener URL:</strong> {getDexScreenerUrl()}</p>
            <p><strong>Chart Embed URL:</strong> {getDexScreenerChartEmbedUrl()}</p>
        </div>
        </DexDebugInfo>
      </div>
    );
  };

  // Add these styled components near the top with other styled components
  const OrderPrice = styled.div`
    color: ${props => props.$type === 'ask' ? 'var(--red)' : 'var(--green)'};
    font-family: 'Roboto Mono', monospace;
    
    sub {
      color: rgba(255, 255, 255, 0.5);
    }
  `;

  const OrderBookTable = styled.div`
    width: 100%;
    font-size: 14px;
    
    .header {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      padding: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      color: #666;
    }
    
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      padding: 4px 8px;
      cursor: pointer;
      
      &:hover {
        background: rgba(255, 255, 255, 0.05);
      }
    }
  `;

  const renderOrderBook = () => {
    return (
      <>
        <OrderBookHeader>
          <span>Price (USDT)</span>
          <span>Amount</span>
          <span>Total</span>
        </OrderBookHeader>
        
        <OrderBookContent>
          <AsksContainer>
            {orderBook.asks && orderBook.asks.map((ask, i) => (
              <OrderBookRow 
                key={`ask-${i}-${ask.price}`}
                $side="sell"
                $depth={50 + (i * 5)} // Calculate depth for visualization
                className={orderBookFlash[`ask-${i}`] ? 'flash' : ''}
                onClick={() => handleOrderBookRowClick(ask.price, 'sell')}
              >
                <span style={{ color: '#F6465D' }}>{formatSmallNumber(ask.price)}</span>
                <span>{formatSmallNumber(ask.amount)}</span>
                <span>{formatSmallNumber(ask.total)}</span>
              </OrderBookRow>
            ))}
          </AsksContainer>
          
          <CurrentPrice $isUp={marketPrice > lastPrice}>
            {!isNaN(parseFloat(marketPrice)) && parseFloat(marketPrice) > 0 
              ? `$${formatSmallNumber(parseFloat(marketPrice))}` 
              : `$${formatSmallNumber(cryptoData?.chartData?.lastPrice || 0)}`}
          </CurrentPrice>
          
          <BidsContainer>
            {orderBook.bids && orderBook.bids.map((bid, i) => (
              <OrderBookRow 
                key={`bid-${i}-${bid.price}`}
                $side="buy"
                $depth={50 + (i * 5)} // Calculate depth for visualization
                className={orderBookFlash[`bid-${i}`] ? 'flash' : ''}
                onClick={() => handleOrderBookRowClick(bid.price, 'buy')}
              >
                <span style={{ color: '#0ECB81' }}>{formatSmallNumber(bid.price)}</span>
                <span>{formatSmallNumber(bid.amount)}</span>
                <span>{formatSmallNumber(bid.total)}</span>
              </OrderBookRow>
            ))}
          </BidsContainer>
        </OrderBookContent>
      </>
    );
  };

  // Add function to handle editing an order
  const handleEditOrderClick = (order) => {
    setEditingOrderId(order.id);
    setEditTargetPrice(order.targetPrice?.toString() || '');
  };

  // Add function to save the edited target price
  const handleSaveTargetPrice = async (orderId) => {
    if (isPending) return;
    
    try {
      setIsPending(true);
      
      // Find the order in question
      const orderToUpdate = pendingLimitOrders.find(o => o.id === orderId);
      if (!orderToUpdate) {
        throw new Error('Order not found');
      }
      
      // Parse the new target price
      const newTargetPrice = parseFloat(editTargetPrice);
      if (isNaN(newTargetPrice) || newTargetPrice <= 0) {
        throw new Error('Invalid price');
      }
      
      // Update the order in Firebase
      await tradingService.updateLimitOrderPrice(currentUser.uid, orderId, newTargetPrice);
      
      // Update local state
      setPendingLimitOrders(prev => 
        prev.map(order => 
          order.id === orderId 
            ? { ...order, targetPrice: newTargetPrice, price: newTargetPrice } 
            : order
        )
      );
      
      // Clear edit state
      setEditingOrderId(null);
      setEditTargetPrice('');
      
      // Notify user
      addNotification({
        title: 'Order Updated',
        message: `Target price updated to $${newTargetPrice.toLocaleString()}`,
        type: 'success'
      });
    } catch (error) {
      console.error('Error updating order:', error);
      addNotification({
        title: 'Update Failed',
        message: error.message || 'Failed to update order',
        type: 'error'
      });
    } finally {
      setIsPending(false);
    }
  };

  const renderPendingLimitOrders = () => {
    if (pendingLimitOrders.length === 0) return null;
    
    return (
      <div style={{ marginTop: '20px', marginBottom: '20px' }}>
        <h3 style={{ 
          margin: '10px 0', 
          color: 'var(--text)', 
          fontSize: '18px', 
          fontWeight: '500',
          borderBottom: '1px solid var(--divider)',
          paddingBottom: '10px'
        }}>Pending Limit Orders</h3>
        
        <PositionsTable>
          <thead>
            <tr>
              <TableHeader>Type</TableHeader>
              <TableHeader>Amount</TableHeader>
              <TableHeader>Target Price</TableHeader>
              <TableHeader>Market Price</TableHeader>
              <TableHeader>Leverage</TableHeader>
              <TableHeader>Margin</TableHeader>
              <TableHeader>Created At</TableHeader>
              <TableHeader>Actions</TableHeader>
            </tr>
          </thead>
          <tbody>
            {pendingLimitOrders.map(order => {
              const createdDate = order.createdAt instanceof Date 
                ? order.createdAt 
                : order.createdAt?.toDate?.() || new Date();
                
              return (
      <tr key={order.id}>
                  <TableCell style={{ 
                    color: order.type === 'buy' ? '#0ECB81' : '#F6465D' 
                  }}>
                    {(order.side || order.type)?.toUpperCase() || 'N/A'}
        </TableCell>
                  <TableCell>{order.amount || 0} {order.symbol || ''}</TableCell>
                  <TableCell>
                    {editingOrderId === order.id ? (
                      <div style={{ display: 'flex', alignItems: 'center' }}>
                        <input 
                          type="number"
                          style={{ 
                            width: '80px',
                            background: 'rgba(255,255,255,0.05)',
                            border: '1px solid rgba(255,255,255,0.1)',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            color: 'white',
                            marginRight: '8px'
                          }}
                          value={editTargetPrice}
                          onChange={(e) => setEditTargetPrice(e.target.value)}
                          min="0.01"
                          step="0.01"
                        />
                        <button
                          style={{
                            background: '#2E7D32',
                            border: 'none',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            color: 'white',
                            cursor: 'pointer',
                            marginRight: '4px'
                          }}
                          onClick={() => handleSaveTargetPrice(order.id)}
                          disabled={isPending}
                        >
                          ✓
                        </button>
                        <button
                          style={{
                            background: '#C62828',
                            border: 'none',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            color: 'white', 
                            cursor: 'pointer'
                          }}
                          onClick={() => setEditingOrderId(null)}
                        >
                          ✕
                        </button>
                      </div>
                    ) : (
                      <div style={{ display: 'flex', alignItems: 'center' }}>
                        ${order.targetPrice?.toLocaleString() || '0.00'}
                        <button
                          style={{
                            background: 'transparent',
                            border: 'none',
                            color: '#64B5F6',
                            cursor: 'pointer',
                            marginLeft: '8px',
                            fontSize: '14px'
                          }}
                          onClick={() => handleEditOrderClick(order)}
                          disabled={isPending || order.isProvisional}
                          title="Edit Target Price"
                        >
                          ✎
                        </button>
                      </div>
                    )}
                  </TableCell>
                  <TableCell>${marketPrice >= 1000 ? marketPrice.toLocaleString() : marketPrice.toLocaleString() || '0.00'}</TableCell>
                  <TableCell>{order.leverage || 1}x</TableCell>
                  <TableCell>${order.margin?.toLocaleString() || '0.00'}</TableCell>
                  <TableCell>
                    {createdDate.toLocaleString()}
                  </TableCell>
        <TableCell>
          <Button
            onClick={() => handleCancelLimitOrder(order.id)}
                      disabled={isPending || order.isProvisional || editingOrderId === order.id}
          >
                      {isPending && order.isProvisional ? 'Processing...' : 'Cancel'}
          </Button>
        </TableCell>
      </tr>
              );
            })}
          </tbody>
        </PositionsTable>
      </div>
    );
  };

  // Add this function inside the Trading component before the render method to ensure 
  // we display prices consistently throughout the order book
  const formatOrderPrice = (price) => {
    // Use the formatSmallNumber function for consistent formatting
    return formatSmallNumber(price);
  };

  // Load user's positions and pending limit orders when authenticated
  useEffect(() => {
    if (!currentUser) return;
    
    const fetchUserData = async () => {
      try {
        // Load existing positions
        const positionsData = await tradingService.getUserPositions(currentUser.uid);
        setPositions(positionsData);
        
        // Load existing pending limit orders
        const pendingOrders = await tradingService.getPendingLimitOrders(currentUser.uid);
        console.log('Loaded pending limit orders:', pendingOrders);
        if (pendingOrders.length > 0) {
          setPendingLimitOrders(pendingOrders);
        }
      } catch (error) {
        console.error('Error loading user data:', error);
      }
    };
    
    fetchUserData();
  }, [currentUser]);
  
  // Direct price listener for immediate limit order execution
  useEffect(() => {
    if (!pendingLimitOrders.length || !marketPrice || !currentUser) return;
    
    console.log(`🔍 Direct price check: ${marketPrice} USDT`);
    
    // Process each limit order against the current price
    pendingLimitOrders.forEach(order => {
      // Skip provisional orders
      if (order.isProvisional) return;
      
      // Skip orders already being executed
      if (ordersBeingExecuted.includes(order.id)) {
        console.log(`🔍 Order ${order.id} is already being executed, skipping direct price check`);
        return;
      }
      
      // Get normalized values
      const orderType = (order.side || order.type || '').toUpperCase();
      const targetPrice = parseFloat(order.price || order.targetPrice);
      const currentPrice = parseFloat(marketPrice);
      
      // Simple comparison logic
      let shouldExecute = false;
      
      if (orderType === 'BUY' && currentPrice <= targetPrice) {
        shouldExecute = true;
        console.log(`🎯 BUY MATCH: Current ${currentPrice} <= Target ${targetPrice}`);
      } else if (orderType === 'SELL' && currentPrice >= targetPrice) {
        shouldExecute = true;
        console.log(`🎯 SELL MATCH: Current ${currentPrice} >= Target ${targetPrice}`);
      }
      
      if (shouldExecute) {
        // Mark this order as being executed
        setOrdersBeingExecuted(prev => [...prev, order.id]);
        
        // Make the conversion here - this is a simpler alternative to the interval-based check
        console.log(`🚀 EXECUTING ORDER ${order.id} immediately on price change!`);
        
        // Remove from pending orders immediately (optimistic)
            setPendingLimitOrders(prev => prev.filter(o => o.id !== order.id));
            
        tradingService.executeLimitOrder(order)
          .then(result => {
            if (result.success) {
              // Play sound effect on successful limit order execution
              playTradeSound();
              
              // Add to open positions
              if (result.position) {
                setOpenPositions(prev => {
                  // Check if position already exists to avoid duplicates
                  const exists = prev.some(p => p.id === result.position.id);
                  if (!exists) {
                    return [...prev, result.position];
                  }
                  return prev;
                });
              }
              
              // Notify user
            addNotification({
                title: 'Limit Order Executed',
                message: `Your ${orderType} order for ${order.amount} ${order.symbol} at ${targetPrice} has been executed!`,
                type: 'success',
                playSound: true
              });
              
              // Refresh data
              if (typeof fetchUserBalances === 'function') fetchUserBalances();
              if (typeof fetchPositions === 'function') fetchPositions();
          } else {
              // Add back to pending orders if failed
              setPendingLimitOrders(prev => [...prev, order]);
              
              console.error('Failed to execute limit order:', result.error);
            addNotification({
              title: 'Execution Failed',
              message: `Failed to execute your order: ${result.error}`,
                type: 'error',
                playSound: false
              });
            }
            
            // Remove from being executed tracking
            setOrdersBeingExecuted(prev => prev.filter(id => id !== order.id));
          })
          .catch(error => {
            // Add back to pending orders if failed
            setPendingLimitOrders(prev => [...prev, order]);
            
            console.error('Failed to execute limit order:', error);
          addNotification({
            title: 'Execution Error',
              message: `Error executing your order: ${error.message}`,
              type: 'error',
              playSound: false
            });
            
            // Remove from being executed tracking
            setOrdersBeingExecuted(prev => prev.filter(id => id !== order.id));
          });
      }
    });
  }, [marketPrice, pendingLimitOrders, currentUser, ordersBeingExecuted]);

  // Add a function to calculate liquidation price based on position details
  const calculateLiquidationPrice = (position) => {
    if (!position || !position.type || !position.entryPrice || !position.leverage) {
      return 0;
    }
    
    // Extract position details
    const { type, entryPrice, leverage, margin } = position;
    const entryPriceNum = parseFloat(entryPrice);
    const leverageNum = parseFloat(leverage);
    const marginNum = parseFloat(margin || 0);
    
    if (isNaN(entryPriceNum) || isNaN(leverageNum) || leverageNum === 0 || marginNum === 0) {
      return 0;
    }
    
    // Calculate the liquidation threshold (percentage of margin that triggers liquidation)
    // Typically this is around 80% of the margin, but can vary based on exchange rules
    const liquidationThreshold = 0.8;
    
    // Calculate liquidation price based on position type (buy/long or sell/short)
    if (type.toLowerCase() === 'buy' || type.toLowerCase() === 'long') {
      // For long positions, liquidation happens when price falls
      // Formula: entry_price - (entry_price / leverage) * liquidationThreshold
      return entryPriceNum * (1 - (liquidationThreshold / leverageNum));
    } else {
      // For short positions, liquidation happens when price rises
      // Formula: entry_price + (entry_price / leverage) * liquidationThreshold
      return entryPriceNum * (1 + (liquidationThreshold / leverageNum));
    }
  };

  useEffect(() => {
    console.log("Order type changed to:", orderType);
  }, [orderType]);

  // Create formatTradingData helper without hooks
  const formatTradingData = (crypto) => {
    if (!crypto) return null;
    return {
      token: {
        id: crypto.id,
        name: crypto.name,
        symbol: crypto.symbol?.toUpperCase(),
        type: crypto.type || 'cex',
        image: crypto.icon || crypto.logoUrl || crypto.logo ||
              `https://coinicons-api.vercel.app/api/icon/${crypto.symbol?.toLowerCase()}`,
        contractAddress: crypto.address || crypto.contractAddress,
        chainId: crypto.chainId || crypto.chain || 'bsc'
      },
      pairInfo: crypto.type === 'dex' ? {
        address: crypto.dexData?.pairAddress,
        dexId: crypto.dexData?.dexId,
        chainId: crypto.chainId || crypto.chain || 'bsc',
        priceUsd: parseFloat(crypto.price?.replace?.('$', '') || 0) 
      } : null,
      chartData: {
        price: parseFloat(typeof crypto.price === 'string' ? crypto.price.replace('$', '') : crypto.price) || 0,
        change24h: parseFloat(crypto.sale || 0),
        volume24h: crypto.volume24h,
        marketCap: crypto.cap
      }
    };
  };

  // Regular function for handling result clicks - no hooks here
  const handleResultClick = (result) => {
    if (!result || !result.id) return;
    
    // Log what we're doing
    console.log('Navigating to trading page with data:', result);
    
    // Create the trading data object without using hooks
    const tradingData = formatTradingData(result);
    
    // Use the navigate function from useNavigate hook (declared at component level)
    navigate(`/trading/${result.id}`, { 
      state: { cryptoData: tradingData }
    });
  };

  // Add error handling for missing data - make sure we always have something to display
  if (!cryptoData) {
    return (
      <TradingContainer>
        <h2>Loading trading data...</h2>
      </TradingContainer>
    );
  }

  return (
    <TradingContainer>
      {cryptoData?.token && (
        <CoinInfo>
          <CoinIcon 
            src={cryptoData.token?.image || `https://coinicons-api.vercel.app/api/icon/${cryptoData.token?.symbol?.toLowerCase()}`} 
            theme={theme} 
            alt={cryptoData.token?.name || 'Crypto'} 
            onError={(e) => {
              e.target.onerror = null;
              e.target.src = `https://coinicons-api.vercel.app/api/icon/${cryptoData.token?.symbol?.toLowerCase()}`;
            }}
          />
          <div>
            <CoinName>{cryptoData.token?.name || 'Bitcoin'}</CoinName>
            <CoinSymbol>{cryptoData.pairInfo?.symbol || `${cryptoData.token?.symbol}/USDT`}</CoinSymbol>
          </div>
          <PriceInfo>
            <CurrentPrice>
              {!isNaN(parseFloat(marketPrice)) && parseFloat(marketPrice) > 0 
                ? `$${formatSmallNumber(parseFloat(marketPrice))}`
                : `$${formatSmallNumber(cryptoData.chartData?.lastPrice || 0)}`}
            </CurrentPrice>
          </PriceInfo>
        </CoinInfo>
      )}

      <TradingGrid>
        {renderChartSection()}

        <RightSection>
          {currentUser ? (
            <>
          <TradingInterface>
            <OrderBookSection>
              <OrderBook>
                {renderOrderBook()}
              </OrderBook>
            </OrderBookSection>

            <OrderFormSection>
              <OrderTypeSelector>
                <OrderTab 
                  active={orderMode === 'market'} 
                  onClick={() => setOrderMode('market')}
                >
                  Market
                </OrderTab>
                <OrderTab 
                  active={orderMode === 'limit'} 
                  onClick={() => setOrderMode('limit')}
                >
                  Limit
                </OrderTab>
              </OrderTypeSelector>

              <OrderForm onSubmit={handleSubmit}>
                <AmountInput
                  key={`amount-${inputKey}`}
                  type="number"
                  value={amount}
                  onChange={(e) => setAmount(e.target.value)}
                  placeholder={`Amount in ${cryptoData.token.symbol}`}
                  min="0"
                  step="0.000001"
                  required
                />

                    {renderLeverageControls()}

                {orderMode === 'limit' && (
                  <AmountInput
                    key={`limit-${inputKey}`}
                    type="number"
                    value={limitPrice}
                    onChange={(e) => setLimitPrice(e.target.value)}
                    placeholder="Limit Price (USDT)"
                    required
                  />
                )}

                <OrderDetails>
                  <DetailRow>
                    <span>Entry Price</span>
                        <span>${orderMode === 'market' ? 
                          (marketPrice ? 
                            marketPrice.toLocaleString(
                              marketPrice < 0.01 ? 6 : 
                              marketPrice < 0.1 ? 5 : 
                              marketPrice < 1 ? 4 : 
                              marketPrice < 10 ? 4 : 
                              marketPrice < 100 ? 3 : 2
                            ) : '0.00') : 
                          (limitPrice || '0.00')}</span>
                  </DetailRow>
                  <DetailRow>
                    <span>Size</span>
                        <span>{amount || '0.00'} {cryptoData?.token?.symbol || ''}</span>
                  </DetailRow>
                  <DetailRow>
                    <span>Leverage</span>
                    <span>{leverage}x</span>
                  </DetailRow>
                </OrderDetails>

                    <div style={{ marginTop: 'auto' }}>
                <TradeInfo>
                  <InfoItem>
                    <span>Required Margin:</span>
                    <span>${calculateRequiredMargin(amount, marketPrice, leverage).toLocaleString()} USDT</span>
                  </InfoItem>
                  <InfoItem $highlight>
                    <span>Available Balance:</span>
                    <span>${typeof userBalance?.USDT === 'number' && !isNaN(userBalance.USDT) ? userBalance.USDT.toLocaleString() : '0.00'} USDT</span>
                  </InfoItem>
                </TradeInfo>

                      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', marginTop: '10px' }}>
                  <OrderButton 
                    $orderType="buy"
                    onClick={() => {
                      setOrderType('buy');
                      // Pass 'buy' directly to handleSubmit to avoid state timing issues
                      handleSubmit(new Event('click'), 'buy');
                    }}
                    disabled={isPending}
                  >
                    {isPending && orderType === 'buy' ? 'Processing...' : `Buy ${cryptoData.token.symbol}`}
                  </OrderButton>
                  <OrderButton 
                    $orderType="sell"
                    onClick={() => {
                      setOrderType('sell');
                      // Pass 'sell' directly to handleSubmit to avoid state timing issues
                      handleSubmit(new Event('click'), 'sell');
                    }}
                    disabled={isPending}
                  >
                    {isPending && orderType === 'sell' ? 'Processing...' : `Sell ${cryptoData.token.symbol}`}
                  </OrderButton>
                      </div>
                </div>
              </OrderForm>
            </OrderFormSection>
          </TradingInterface>
            </>
          ) : (
            <LoginPrompt>
              <h3>Login to Trade</h3>
              <p>Create an account or login to start trading {cryptoData?.name || 'cryptocurrencies'}.</p>
              <ButtonGroup>
                <StyledButton onClick={() => window.location.href = '/login'}>Login</StyledButton>
                <StyledButton onClick={() => window.location.href = '/register'}>Register</StyledButton>
              </ButtonGroup>
            </LoginPrompt>
          )}
        </RightSection>
      </TradingGrid>

      {renderPendingLimitOrders()}

      {(isLoadingPositions ? true : openPositions.length > 0 || closedPositions.length > 0) && (
        <div style={{ marginTop: '20px' }}>
          <Tabs>
            <TabList>
              <Tab>Open Positions ({openPositions.filter(p => p.symbol === cryptoData?.token?.symbol).length})</Tab>
              <Tab>Closed Positions ({closedPositions.filter(p => p.symbol === cryptoData?.token?.symbol).length})</Tab>
            </TabList>

            <TabPanel>
              {isLoadingPositions ? (
                <div style={{ textAlign: 'center', padding: '20px' }}>Loading positions...</div>
              ) : openPositions.filter(p => p.symbol === cryptoData?.token?.symbol).length > 0 ? (
          <PositionsTable>
            <thead>
              <tr>
                <TableHeader>Type</TableHeader>
                <TableHeader>Amount</TableHeader>
                <TableHeader>Entry Price</TableHeader>
                <TableHeader>Mark Price</TableHeader>
                <TableHeader>Liquidation</TableHeader>
                <TableHeader>Leverage</TableHeader>
                <TableHeader>PnL (ROE %)</TableHeader>
                <TableHeader>Actions</TableHeader>
              </tr>
            </thead>
            <tbody>
                    {openPositions
                      .filter(position => position.symbol === cryptoData?.token?.symbol)
                      .map(position => {
                      const pnl = calculatePnL(position, marketPrice) || 0;
                      const roe = position.margin ? ((pnl / position.margin) * 100).toLocaleString() : '0.00';
                      const liquidationPrice = calculateLiquidationPrice(position);
                
                return (
                  <tr key={position.id}>
                    <TableCell style={{ 
                      color: position.side === 'sell' ? '#F6465D' : '#0ECB81' 
                    }}>
                      {position.side?.toUpperCase() || position.type?.toUpperCase() || 'N/A'}
                    </TableCell>
                          <TableCell>{position.amount || 0} {position.symbol || ''}</TableCell>
                    <TableCell>${position.entryPrice?.toLocaleString() || '0.00'}</TableCell>
                    <TableCell>${marketPrice >= 1000 ? marketPrice.toLocaleString() : marketPrice.toLocaleString() || '0.00'}</TableCell>
                    <TableCell style={{ color: '#F44336' }}>
                      ${liquidationPrice.toLocaleString()}
                    </TableCell>
                          <TableCell>{position.leverage || 1}x</TableCell>
                    <TableCell>
                      <PnLValue value={pnl}>
                        ${pnl.toLocaleString()} ({roe}%)
                      </PnLValue>
                    </TableCell>
                    <TableCell>
                      <Button
                              onClick={() => handleClosePosition(position)}
                              disabled={isPending && closingPositionId === position.id}
                            >
                              {isPending && closingPositionId === position.id ? 'Processing...' : 'Close'}
                      </Button>
                    </TableCell>
                  </tr>
                );
              })}
            </tbody>
          </PositionsTable>
              ) : (
                <div style={{ textAlign: 'center', padding: '20px' }}>No open positions for {cryptoData?.token?.symbol || 'this pair'}</div>
              )}
            </TabPanel>

            <TabPanel>
              {isLoadingPositions ? (
                <div style={{ textAlign: 'center', padding: '20px' }}>Loading positions...</div>
              ) : closedPositions.filter(p => p.symbol === cryptoData?.token?.symbol).length > 0 ? (
                <PositionsTable>
                  <thead>
                    <tr>
                      <TableHeader>Type</TableHeader>
                      <TableHeader>Amount</TableHeader>
                      <TableHeader>Entry Price</TableHeader>
                      <TableHeader>Close Price</TableHeader>
                      <TableHeader>Leverage</TableHeader>
                      <TableHeader>Final PnL</TableHeader>
                      <TableHeader>Close Time</TableHeader>
                    </tr>
                  </thead>
                  <tbody>
                    {closedPositions
                      .filter(position => position.symbol === cryptoData?.token?.symbol)
                      .map(position => (
                      <tr key={position.id}>
                        <TableCell style={{ 
                          color: position.side === 'sell' ? '#F6465D' : '#0ECB81' 
                        }}>
                          {position.side?.toUpperCase() || position.type?.toUpperCase() || 'N/A'}
                        </TableCell>
                        <TableCell>{position.amount || 0} {position.symbol || ''}</TableCell>
                        <TableCell>${position.entryPrice?.toLocaleString() || '0.00'}</TableCell>
                        <TableCell>${position.closePrice?.toLocaleString() || '0.00'}</TableCell>
                        <TableCell>{position.leverage || 1}x</TableCell>
                        <TableCell>
                          <PnLValue value={position.finalPnL || 0}>
                            ${(position.finalPnL || 0).toLocaleString()}
                          </PnLValue>
                        </TableCell>
                        <TableCell>
                          {position.closeTime ? 
                            new Date(position.closeTime).toLocaleString() : 
                            'N/A'
                          }
                        </TableCell>
                      </tr>
                    ))}
                  </tbody>
                </PositionsTable>
              ) : (
                <div style={{ textAlign: 'center', padding: '20px' }}>No closed positions for {cryptoData?.token?.symbol || 'this pair'}</div>
              )}
            </TabPanel>
          </Tabs>
        </div>
      )}

      {!isOnline && (
        <StatusMessage error>
          You are currently offline. Some features may be unavailable.
        </StatusMessage>
      )}

      {error && (
        <StatusMessage error>
          {error}
        </StatusMessage>
      )}
    </TradingContainer>
  );
}

// Add new styled components
const LoginPrompt = styled.div`
  text-align: center;
  padding: 40px;
  background: var(--bg2);
  border-radius: 8px;
  margin: 20px;
`;

const ButtonGroup = styled.div`
  display: flex;
  gap: 16px;
  justify-content: center;
`;

const StyledButton = styled.button`
  padding: 12px 24px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.3s ease;

  &:first-child {
    background: var(--primary);
    color: white;

    &:hover {
      background: var(--primary-dark);
    }
  }

  &:last-child {
    background: transparent;
    border: 1px solid var(--primary);
    color: var(--primary);

    &:hover {
      background: var(--primary);
      color: white;
    }
  }
`;

const StatusMessage = styled.div`
  color: ${props => props.error ? '#F6465D' : '#0ECB81'};
  padding: 8px;
  text-align: center;
  background: ${props => props.error ? 'rgba(246, 70, 93, 0.1)' : 'rgba(14, 203, 129, 0.1)'};
  border-radius: 4px;
  margin-bottom: 16px;
`;

// Add these new styled components for the professional order book
const OrderBookArrow = styled.span`
  color: ${props => props.$direction === 'up' ? '#0ECB81' : '#F6465D'};
  margin-right: 4px;
  font-size: 14px;
`;

const OrderBookFlag = styled.span`
  color: #F0B90B;
  margin-left: 4px;
  font-size: 12px;
`;

const OrderBookRatio = styled.div`
  display: flex;
  align-items: center;
  height: 28px;
  background: linear-gradient(
    to right,
    rgba(14, 203, 129, 0.2) ${props => props.$buyPercent}%,
    rgba(246, 70, 93, 0.2) ${props => props.$buyPercent}%
  );
  margin-top: 8px;
  border-radius: 4px;
  overflow: hidden;
`;

const RatioIndicator = styled.div`
  display: flex;
  width: 100%;
  justify-content: space-between;
  padding: 0 8px;
  align-items: center;
  
  span {
    font-size: 12px;
    font-weight: 500;
    padding: 3px 6px;
    border-radius: 4px;
    
    &:first-child {
      background: rgba(14, 203, 129, 0.3);
      color: #0ECB81;
    }
    
    &:last-child {
      background: rgba(246, 70, 93, 0.3);
      color: #F6465D;
    }
  }
`;

export default Trading; 